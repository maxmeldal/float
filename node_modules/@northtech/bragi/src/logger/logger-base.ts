import { Observable, Observer } from 'rxjs';

export type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR';

export interface LogEntry<T extends string> {
  readonly id: number;
  readonly level: LogLevel;
  readonly component: T;
  readonly message: string;
  readonly detailObject?: any;
  readonly error?: Error | undefined;
  readonly timestampMillis: number;
}

/**
 * @experimental
 *
 * The generic type `COMPONENT_NAMES` can be used to restrict the possible component names. At heart, it is just a string
 * (and it's fully valid to create a `Logger<string>`), but to enforce consistency, you can implement it as a union type
 * of specific strings, e.g. `Logger<'network' | 'login' | 'unknown'>`.
 */
export class LoggerBase<ComponentNamesT extends string> extends Observable<LogEntry<ComponentNamesT>> {
  #observers = new Set<Observer<LogEntry<ComponentNamesT>>>();
  #entry: LogEntry<ComponentNamesT> | undefined;
  #idRunner = 0;

  constructor() {
    super((observer => {
      // Replay current value to new subscribers:
      if (this.#entry) {
        observer.next(this.#entry);
      }
      this.#observers.add(observer);
      // Teardown logic on unsubscription:
      return () => {
        this.#observers.delete(observer);
      };
    }));
  }

  debug(component: ComponentNamesT, message: string, detailObjectOrError?: any, error?: any): void {
    this.log('DEBUG', component, message, detailObjectOrError, error);
  }

  info(component: ComponentNamesT, message: string, detailObjectOrError?: any, error?: any): void {
    this.log('INFO', component, message, detailObjectOrError, error);
  }

  warn(component: ComponentNamesT, message: string, detailObjectOrError?: any, error?: any): void {
    this.log('WARN', component, message, detailObjectOrError, error);
  }

  error(component: ComponentNamesT, message: string, detailObjectOrError?: any, error?: any): void {
    this.log('ERROR', component, message, detailObjectOrError, error);
  }

  log(level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR', component: ComponentNamesT, message: string, detailObjectOrError?: any, error?: any): void {
    let traceObject: any;
    if (error) {
      traceObject = detailObjectOrError;
    } else if (detailObjectOrError instanceof Error) {
      error = detailObjectOrError;
    } else {
      traceObject = detailObjectOrError;
    }
    const entry: LogEntry<ComponentNamesT> = {
      id: ++this.#idRunner,
      level,
      component,
      message,
      detailObject: traceObject,
      error,
      timestampMillis: Date.now()
    };
    this.#observers.forEach(obs => obs.next(entry));
  }
}
