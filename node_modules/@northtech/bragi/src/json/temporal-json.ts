import { PickKeys } from 'ts-essentials';
import { Temporal } from '@js-temporal/polyfill';

/**
 * I am not happy with this one. It's not obvious how to combine it with handling other than Temporal fields, and it
 * does not handle nested objects.
 */
export class TemporalJson<T> {
  private readonly parsers: { [k in keyof T]?: any } = {};

  instantFields(...k: PickKeys<T, Temporal.Instant | undefined | null>[]): this {
    k.forEach(key => this.parsers[key] = (v: any) => v ? Temporal.Instant.from(v) : undefined);
    return this;
  }

  /**
   * Be aware that this one requires an actual ZonedDateTime notation, i.e. with full bracketed, city-based zone ID.
   * (Consider whether what you want is actually an Instant field which is formatted in the UI, or the {@link zonedDateTimesFromInstantFields}).
   */
  zonedDateTimeFields(...k: PickKeys<T, Temporal.ZonedDateTime | undefined | null>[]): this {
    k.forEach(key => this.parsers[key] = (v: any) => v ? Temporal.ZonedDateTime.from(v) : undefined);
    return this;
  }

  plainDateFields(...k: PickKeys<T, Temporal.PlainDate | undefined | null>[]): this {
    k.forEach(key => this.parsers[key] = (v: any) => v ? Temporal.PlainDate.from(v) : undefined);
    return this;
  }

  plainTimeFields(...k: PickKeys<T, Temporal.PlainTime | undefined | null>[]): this {
    k.forEach(key => this.parsers[key] = (v: any) => v ? Temporal.PlainTime.from(v) : undefined);
    return this;
  }

  zonedDateTimesFromInstantFields(
    zoneId: (Temporal.TimeZoneProtocol | string | { timeZone: Temporal.TimeZoneProtocol | string }),
    ...k: PickKeys<T, Temporal.ZonedDateTime | undefined | null>[]
  ): this {
    k.forEach(key => this.parsers[key] = (v: any) => v ? Temporal.Instant.from(v).toZonedDateTimeISO(zoneId) : undefined);
    return this;
  }

  fieldParser<KeyT extends keyof T>(k: KeyT, parser: (v: any) => T[KeyT]): this {
    this.parsers[k] = (v: any) => v == null ? v : parser(v);
    return this;
  }

  deserializeTemporalFields(o: any): T {
    const result = {...o};
    (Object.keys(this.parsers) as (keyof T)[])
      .forEach(k => {
        result[k] = this.parsers[k](o[k]);
      });
    return result;
  }

  reviver(k: string, v: any): any {
    if (v == null) {
      return v;
    }
    const parser: any = this.parsers[k as keyof T];
    if (parser) return parser(v);
    return v;
  }
}
