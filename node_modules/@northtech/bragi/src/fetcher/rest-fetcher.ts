import { JsonFetcher } from './json-fetcher';
import { RequestRewriters } from './rewriting-fetcher';
import { JsonConverter } from '../json';
import { delay, EMPTY, filter, map, Observable, retryWhen, share, shareReplay, switchMap, take } from 'rxjs';
import { resolveTemplate } from '@northtech/ginnungagap';
import { ensureLeadingQuestionmark, toQueryString } from './url-tools';

export class RestFetcher<ItemT, ErrorT> extends JsonFetcher<ItemT, ErrorT> {
  readonly itemUrlTemplate: Observable<string>;
  readonly listUrlTemplate: Observable<string>;
  readonly GETRetryMillis: number;

  constructor(config: {
    requestRewriters?: RequestRewriters | undefined;
    jsonConverter?: JsonConverter<ItemT> | undefined;
    errorJsonConverter?: JsonConverter<ErrorT> | undefined;

    itemUrlTemplate: string | Observable<string>;
    listUrlTemplate: string | Observable<string>;
    // I am unsure whether this belongs in Bragi, or should be handled by the client code.
    GETRetryMillis?: number | undefined;
  }) {
    super(config);
    const itemUrlTemplate = config.itemUrlTemplate;
    this.itemUrlTemplate = typeof itemUrlTemplate === 'string'
      ? new Observable<string>((subscriber) => subscriber.next(itemUrlTemplate))
      : itemUrlTemplate.pipe(shareReplay(1));
    const collectionUrlTemplate = config.listUrlTemplate;
    this.listUrlTemplate = typeof collectionUrlTemplate === 'string'
      ? new Observable<string>((subscriber) => subscriber.next(collectionUrlTemplate))
      : collectionUrlTemplate.pipe(shareReplay(1));
    this.GETRetryMillis = config.GETRetryMillis == null ? 30000 : config.GETRetryMillis;
  }

  get(id: Partial<ItemT>): Observable<ItemT> {
    return this.itemUrlTemplate.pipe(
      take(1),
      switchMap(urlTemplate => this.fetchJson(resolveTemplate(urlTemplate, id, true))
        .pipe(retryWhen(err =>
          this.GETRetryMillis > 0
            ? err.pipe(delay(this.GETRetryMillis))
            : EMPTY
        ))
      ),
      map(res => res.item)
    );
  }

  // It bothers me that we'll have to send a dummy parameter in most cases to be allowed to use the query parameter,
  // but there is no real way to recognize whether a record-y object is meant as path params or query params.
  list(pathParams?: Record<string, any> | undefined | null, query?: string | { [key: string]: string | number | boolean | undefined | null } | undefined | null): Observable<ItemT[]> {
    return this.listUrlTemplate.pipe(
      take(1),
      switchMap(urlTemplate => this.fetchJsonList(
          resolveTemplate(urlTemplate, pathParams, true) + ensureLeadingQuestionmark(toQueryString(query))
        )
          .pipe(retryWhen(err =>
            this.GETRetryMillis > 0
              ? err.pipe(delay(this.GETRetryMillis))
              : EMPTY
          ))
      ),
      map(res => res.items)
    );
  }

  put(item: Partial<ItemT>): Observable<ItemT> {
    const obs = this.itemUrlTemplate.pipe(
      take(1),
      switchMap(urlTemplate => this.fetchJson(resolveTemplate(urlTemplate, item, true), {method: 'PUT', body: item})),
      map(res => res.item),
      share()
    );
    obs.subscribe({
      error: () => {
        // Suppress console errors from this anonymous listener
      }
    });
    return obs;
  }

  post(item: Partial<ItemT>): Observable<ItemT> {
    const obs = this.listUrlTemplate.pipe(
      take(1),
      switchMap(urlTemplate => this.fetchJson(resolveTemplate(urlTemplate, item, true), {method: 'POST', body: item})),
      map(res => res.item),
      share()
    );
    obs.subscribe({
      error: () => {
        // Suppress console errors from this anonymous listener
      }
    });
    return obs;
  }

  delete(id: Partial<ItemT>): Observable<never> {
    const obs = this.itemUrlTemplate.pipe(
      take(1),
      switchMap(urlTemplate => this.fetchJson(resolveTemplate(urlTemplate, id, true), {method: 'DELETE'}) as Observable<never>),
      filter(_ => false),
      share()
    );
    obs.subscribe({
      error: () => {
        // Suppress console errors from this anonymous listener
      }
    });
    return obs;
  }

  /*
  private resolve(urlTemplate: string, pathParams: Partial<ItemT>): string {
    const url = resolveTemplate(urlTemplate, pathParams, false);
    if (url == null) {
      const incomplete = resolveTemplate(urlTemplate, pathParams, true);
      console.warn('Missing parameters for URL template', incomplete, 'when filled out with object', pathParams);
      return incomplete;
    } else {
      return url;
    }
  }
  */
}
