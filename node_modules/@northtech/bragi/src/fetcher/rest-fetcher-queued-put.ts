import { BehaviorSubject, finalize, Observable, Subject, take } from 'rxjs';
import { isNotUndefined, resolveTemplate } from '@northtech/ginnungagap';
import { RestFetcher } from './rest-fetcher';
import { RequestRewriters } from './rewriting-fetcher';
import { JsonConverter } from '../json';

export class RestFetcherQueuedPut<ItemT, ErrorT> extends RestFetcher<ItemT, ErrorT> {
  readonly #prefix = 'upload-' + this.constructor.name;
  static #idRunner = Date.now();
  readonly queuedWrites = new BehaviorSubject(0);
  static readonly inflightUploads = new BehaviorSubject(0);
  readonly #uploaded = new Subject<ItemT>();
  readonly uploaded = this.#uploaded.asObservable();

  constructor(config: {
    requestRewriters?: RequestRewriters | undefined;
    jsonConverter?: JsonConverter<ItemT> | undefined;
    errorJsonConverter?: JsonConverter<ErrorT> | undefined;
    itemUrlTemplate: string | Observable<string>;
    listUrlTemplate: string | Observable<string>;
    GETRetryMillis?: number | undefined;
    queuedPUTRetryMillis?: number | undefined;
  }) {
    super(config);
    setInterval(() => this.tick(), (config.queuedPUTRetryMillis && config.queuedPUTRetryMillis > 0) ? config.queuedPUTRetryMillis : 30000);
  }

  queuePut(item?: Partial<ItemT> | undefined) {
    this.itemUrlTemplate.pipe(take(1))
      .subscribe(urlTemplate => {
        const url = resolveTemplate(urlTemplate, item, true);
        const body = this.jsonConverter.objectToString(item);
        this.queueInternal({url, method: 'PUT', body});
        this.tick();
      });
  }

  private queueInternal(uploadEntry: UploadEntry) {
    try {
      window.localStorage.setItem(this.#prefix + (++RestFetcherQueuedPut.#idRunner), JSON.stringify(uploadEntry));
    } catch (error) {
      this.doUpload(undefined, uploadEntry);
    }
  }

  private doUpload(key: string | undefined, uploadEntry: UploadEntry) {
    RestFetcherQueuedPut.inflightUploads.next(RestFetcherQueuedPut.inflightUploads.value + 1);
    this.fetchJson(uploadEntry.url, {method: uploadEntry.method, body: uploadEntry.body})
      .pipe(
        finalize(() => {
          RestFetcherQueuedPut.inflightUploads.next(RestFetcherQueuedPut.inflightUploads.value - 1);
          if (key) {
            window.localStorage.removeItem(key);
          }
        })
      )
      .subscribe({
        next: res => this.#uploaded.next(res.item),
        error: _ => {
          // Move the upload data to the end of queue to prevent it from blocking other uploads:
          this.queueInternal(uploadEntry);
        },
        complete: () => {
          // Queue the next tick for immediate execution, rather than waiting for the normal schedule.
          // (Queueing rather than calling it directly allows the current call stack to complete, including running
          // finalizers).
          setTimeout(() => this.tick(), 0);
        }
      });
  }

  private tick(): void {
    if (RestFetcherQueuedPut.inflightUploads.value === 0) {
      const uploadKey = this.nextUploadKey();
      if (uploadKey) {
        const jsonEntry = window.localStorage.getItem(uploadKey);
        if (jsonEntry != null) {
          let upload: UploadEntry | undefined;
          try {
            upload = JSON.parse(jsonEntry);
          } catch (err) {
            // We could not parse the JSON. Nothing can recover from that, so delete the entry;
            console.error('Incorrect JSON in localStorage. Removing upload item ', uploadKey, jsonEntry, err);
            window.localStorage.removeItem(uploadKey);
          }
          if (upload != null) {
            this.doUpload(uploadKey, upload);
          }
        }
      }
    }
  }

  queuedItems(): ItemT[] {
    return Object.keys(window.localStorage)
      .filter(s => s.startsWith(this.#prefix))
      .map(key => {
        const jsonEntry = window.localStorage.getItem(key);
        if (jsonEntry == null) return undefined;
        try {
          return JSON.parse(jsonEntry) as UploadEntry;
        } catch (err) {
          // Ignore the error here and let the normal tick deal with it:
          return undefined;
        }
      })
      .filter(isNotUndefined)
      .map(entry => this.jsonConverter.stringToObject(entry.body))
      .filter(isNotUndefined);
  }


  private nextUploadKey(): string | undefined {
    const uploads = Object.keys(window.localStorage)
      .filter(s => s.startsWith(this.#prefix));
    this.queuedWrites.next(uploads.length);
    return uploads.sort((a, b) => this.keyToNumber(a) - this.keyToNumber(b))[0];
  }

  private keyToNumber(k: string): number {
    return parseInt(k.substring(this.#prefix.length), 10);
  }
}

interface UploadEntry {
  url: string;
  method: 'GET' | 'PUT' | 'POST' | 'DELETE';
  body?: string | undefined;
}
