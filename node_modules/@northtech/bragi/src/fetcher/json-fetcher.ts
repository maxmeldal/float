import { RequestRewriters, RewritingFetcher } from './rewriting-fetcher';
import { JsonConverter } from '../json';
import { BehaviorSubject, EMPTY, finalize, from, Observable, switchMap } from 'rxjs';

export class JsonFetcher<ItemT, ErrorT> extends RewritingFetcher {
  readonly inflightReads = new BehaviorSubject(0);
  readonly inflightWrites = new BehaviorSubject(0);
  readonly error = new BehaviorSubject<HttpError<ErrorT> | undefined>(undefined);

  readonly jsonConverter: JsonConverter<ItemT>;
  readonly errorJsonConverter: JsonConverter<ErrorT>;

  constructor(config?: {
    requestRewriters?: RequestRewriters | undefined;
    jsonConverter?: JsonConverter<ItemT> | undefined;
    errorJsonConverter?: JsonConverter<ErrorT> | undefined;
  }) {
    super(config);
    this.jsonConverter = (config?.jsonConverter)
      ? config.jsonConverter
      : new JsonConverter<ItemT>();
    this.errorJsonConverter = (config?.errorJsonConverter)
      ? config.errorJsonConverter
      : new JsonConverter<ErrorT>();
  }

  fetchJson(url: string, typedRequestInit?: Omit<RequestInit, 'body'> & { body?: Partial<ItemT> | string | undefined }): Observable<{ response: Response, item: ItemT }> {
    return this.fetchJsonInternal(url, false, typedRequestInit);
  }

  fetchJsonList(url: string, typedRequestInit?: Omit<RequestInit, 'body'> & { body?: Partial<ItemT>[] | string | undefined }): Observable<{ response: Response, items: ItemT[] }> {
    return this.fetchJsonInternal(url, true, typedRequestInit);
  }

  private fetchJsonInternal(url: string, list: false, typedRequestInit?: Omit<RequestInit, 'body'> & { body?: Partial<ItemT> | string | undefined }): Observable<{ response: Response, item: ItemT }>;
  private fetchJsonInternal(url: string, list: true, typedRequestInit?: Omit<RequestInit, 'body'> & { body?: Partial<ItemT>[] | string | undefined }): Observable<{ response: Response, items: ItemT[] }>;
  private fetchJsonInternal(url: string, list: boolean, typedRequestInit?: Omit<RequestInit, 'body'> & { body?: Partial<ItemT> | Partial<ItemT>[] | string | undefined }): Observable<{ response: Response, item?: ItemT, items?: ItemT[] }> {
    const body: string | undefined = (typedRequestInit?.body != null)
      ? (typeof typedRequestInit.body === 'string' ? typedRequestInit.body : this.jsonConverter.objectToString(typedRequestInit.body))
      : undefined;

    const requestInit: RequestInit = {
      ...typedRequestInit,
      body,
      headers: {
        ...typedRequestInit?.headers,
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      }
    };

    const inflightTracker = this.getInflightTracker(requestInit);
    inflightTracker.next(inflightTracker.value + 1);
    return this.fetch(url, requestInit).pipe(
      finalize(() => inflightTracker.next(inflightTracker.value - 1)),
      switchMap(res => {
        if (res.status === 204 || res.status === 205 || res.status === 304) {
          this.error.next(undefined);
          // The server is explicitly not sending any data. In the context of a JSON fetch, the most reasonable
          // interpretation is "completed successfully, with no object delivered".
          return EMPTY;
        } else if (res.status >= 200 && res.status < 300) {
          this.error.next(undefined);
          return from(
            res.text()
              .then(json => list ? ({
                  response: res,
                  items: this.jsonConverter.stringToArray(json)
                })
                : ({
                  response: res,
                  item: this.jsonConverter.stringToObject(json)
                }))
          );
        }
        // Anything but the 200 range is, in the context of fetching a JSON object, an error.
        // (And even then, many of the 2xx codes are of questionable use).
        return from(
          this.parseError(res)
            .then(e => {
              this.error.next(e);
              throw e;
            })
        );
      })
    );
  }

  private parseError(response: Response): Promise<HttpError<ErrorT>> {
    return response.text()
      .then(text => {
        let error: ErrorT | undefined = undefined;
        let errorString: string | undefined = undefined;
        try {
          error = this.errorJsonConverter.stringToObject(text);
        } catch (e) {
          errorString = text;
        }
        return new HttpError(response, error, errorString);
      });
  }

  private getInflightTracker(requestInit: RequestInit | undefined): BehaviorSubject<number> {
    const method = requestInit?.method == null ? 'GET' : requestInit.method.toUpperCase();
    return method === 'PUT' || method === 'POST' || method === 'DELETE'
      ? this.inflightWrites
      : this.inflightReads;
  }
}

export class HttpError<ErrorT> extends Error {
  constructor(readonly response: Response,
              readonly error: ErrorT | undefined,
              readonly errorString: string | undefined) {
    super(response.status + ' - ' + response.url + (errorString ? (' - ' + errorString) : '') + (error ? (' - ' + JSON.stringify(error)) : ''));
    // Practically, we gain very little from a stack trace at this point.
    /*
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    */
    this.name = this.constructor.name;
  }
}
