import {
  BehaviorSubject,
  filter,
  finalize,
  from,
  isObservable,
  Observable,
  ReplaySubject,
  share,
  switchMap,
  take
} from 'rxjs';
import { isNotUndefined } from '@northtech/ginnungagap';


/**
 * Carries the url string and RequestInit needed for a fetch call, without being a fully instantiated Request object,
 * making it easier to manipulate with simple field manipulations.
 */
export interface SimpleRequest {
  url: string;
  requestInit?: RequestInit | undefined;
}

/**
 * A rewriter is a function which takes a RequestData and returns a (possibly) modified version of it. This would
 * typically be adding necessary Authentication headers, but in principle it can rewrite anything.
 * (A RequestRewriter can also reject a request by throwing an {@Link Aborted} exception).
 */
export type RequestRewriter = (request: SimpleRequest) => SimpleRequest | Promise<SimpleRequest> | Observable<SimpleRequest>;

/**
 * A default implementation of a {@link RequestRewriter} which doesn't manipulate the request at all.
 */
export const ANONYMOUS: RequestRewriter = o => o;
/**
 * A default implementation of a {@link RequestRewriter} which always throws an {@link Aborted} error. (E.g. if the user
 * has not logged in yet, and all attempts to contact a server endpoint should be denied).
 */
export const ABORT: RequestRewriter = o => {
  throw new Aborted(o);
};

// It is common for different requests to require different credentials
export interface RequestRewriters {
  ALL?: RequestRewriter | undefined;
  ALL_WRITES?: RequestRewriter | undefined;
  GET?: RequestRewriter | undefined;
  PUT?: RequestRewriter | undefined;
  POST?: RequestRewriter | undefined;
  PATCH?: RequestRewriter | undefined;
  DELETE?: RequestRewriter | undefined;
}

/**
 * An error subclass intended to be used by the {@link RequestRewriter} to signal that the request was deliberately
 * aborted.
 */
export class Aborted extends Error {
  constructor(readonly request: SimpleRequest) {
    super();
  }
}

export function setHeader(request: SimpleRequest, name: string, value: string): SimpleRequest {
  const headers = {...request.requestInit?.headers, [name]: value};
  return ({
    url: request.url,
    requestInit: {...request.requestInit, headers}
  });
}

export function setHeaders(request: SimpleRequest, headers: Record<string, string>): SimpleRequest {
  const h = {...request.requestInit?.headers, ...headers};
  return ({
    url: request.url,
    requestInit: {...request.requestInit, headers: h}
  });
}

/**
 * The `RewritingFetcher` is a fairly thin layer around the native `fetch` method, allowing asynchronous manipulation of
 * the request before it is sent. The primary motivation is adding authorization headers, likely based on a refresh
 * token, but the rewriter can in principle manipulate the request in any way.
 */
export class RewritingFetcher {
  private readonly requestRewriters = new ReplaySubject<RequestRewritersByMethod | undefined>(1);
  static readonly inflightReads = new BehaviorSubject(0);
  static readonly inflightWrites = new BehaviorSubject(0);

  constructor(config?: {
    requestRewriters?: RequestRewriters | undefined;
  }) {
    this.requestRewriters.next(prioritizeRewriters(config?.requestRewriters));
  }

  /**
   * A RequestRewriter _must_ be set (even if just the do-nothing {@link ANONYMOUS} rewriter) before a server can be
   * contacted. (The Fetcher cannot make assumptions and default to an anonymous access attempt, since we do not want
   * to spam requests to a server which requires login before the login rewriter is ready).
   */
  setRequestRewriter(requestRewriters: RequestRewriters): this {
    this.requestRewriters.next(prioritizeRewriters(requestRewriters));
    return this;
  }

  fetch(url: string, requestInit?: RequestInit): Observable<Response>;
  fetch(request: SimpleRequest): Observable<Response>;
  fetch(requestOrUrl: SimpleRequest | string, requestInit?: RequestInit): Observable<Response> {
    let request: SimpleRequest;
    if (typeof requestOrUrl === 'string') {
      request = {url: requestOrUrl, requestInit};
    } else {
      request = requestOrUrl;
    }
    const obs = this.requestRewriters.pipe(
      filter(isNotUndefined),
      take(1),
      switchMap(rewriters => {
        const rewritten = pickRewriter(request, rewriters)(request);
        return isObservable(rewritten)
          ? rewritten.pipe(take(1))
          : from(Promise.resolve(rewritten));
      }),
      switchMap(req => {
        const inflightTracker = RewritingFetcher.getInflightTracker(request.requestInit);
        inflightTracker.next(inflightTracker.value + 1);
        return from(fetch(req.url, req.requestInit))
          .pipe(finalize(() => inflightTracker.next(inflightTracker.value - 1)));
      }),
      share()
    );
    // Make sure the fetch actually fires regardless of client listeners, to obey the principle of least astonishment
    obs.subscribe({
      error: () => {
        // Suppress console errors from this anonymous listener
      }
    });
    return obs;
  }

  private static getInflightTracker(requestInit: RequestInit | undefined): BehaviorSubject<number> {
    const method = requestInit?.method == null ? 'GET' : requestInit.method.toUpperCase();
    return method === 'PUT' || method === 'POST' || method === 'DELETE'
      ? RewritingFetcher.inflightWrites
      : RewritingFetcher.inflightReads;
  }
}

interface RequestRewritersByMethod {
  GET: RequestRewriter | undefined;
  PUT: RequestRewriter | undefined;
  POST: RequestRewriter | undefined;
  PATCH: RequestRewriter | undefined;
  DELETE: RequestRewriter | undefined;
}

function pickRewriter(request: SimpleRequest, rewriters: RequestRewritersByMethod): RequestRewriter {
  const method = (request.requestInit?.method?.toUpperCase() ?? 'GET') as keyof RequestRewritersByMethod;
  const rewriter = rewriters[method];
  if (!rewriter) throw new Error('No RequestRewriter given for method ' + method);
  return rewriter;
}

function prioritizeRewriters(rewriters: RequestRewriters | undefined): RequestRewritersByMethod | undefined {
  if (rewriters == null) return undefined;
  return {
    GET: rewriters.GET != null ? rewriters.GET : rewriters.ALL,
    PUT: rewriters.PUT != null ? rewriters.PUT : (rewriters.ALL_WRITES != null ? rewriters.ALL_WRITES : rewriters.ALL),
    POST: rewriters.POST != null ? rewriters.POST : (rewriters.ALL_WRITES != null ? rewriters.ALL_WRITES : rewriters.ALL),
    PATCH: rewriters.PATCH != null ? rewriters.PATCH : (rewriters.ALL_WRITES != null ? rewriters.ALL_WRITES : rewriters.ALL),
    DELETE: rewriters.DELETE != null ? rewriters.DELETE : (rewriters.ALL_WRITES != null ? rewriters.ALL_WRITES : rewriters.ALL)
  };
}
