import { Temporal } from '@js-temporal/polyfill';
/**
 * I am not happy with this one. It's not obvious how to combine it with handling other than Temporal fields, and it
 * does not handle nested objects.
 */
export class TemporalJson {
    constructor() {
        this.parsers = {};
    }
    instantFields(...k) {
        k.forEach(key => this.parsers[key] = (v) => v ? Temporal.Instant.from(v) : undefined);
        return this;
    }
    /**
     * Be aware that this one requires an actual ZonedDateTime notation, i.e. with full bracketed, city-based zone ID.
     * (Consider whether what you want is actually an Instant field which is formatted in the UI, or the {@link zonedDateTimesFromInstantFields}).
     */
    zonedDateTimeFields(...k) {
        k.forEach(key => this.parsers[key] = (v) => v ? Temporal.ZonedDateTime.from(v) : undefined);
        return this;
    }
    plainDateFields(...k) {
        k.forEach(key => this.parsers[key] = (v) => v ? Temporal.PlainDate.from(v) : undefined);
        return this;
    }
    plainTimeFields(...k) {
        k.forEach(key => this.parsers[key] = (v) => v ? Temporal.PlainTime.from(v) : undefined);
        return this;
    }
    zonedDateTimesFromInstantFields(zoneId, ...k) {
        k.forEach(key => this.parsers[key] = (v) => v ? Temporal.Instant.from(v).toZonedDateTimeISO(zoneId) : undefined);
        return this;
    }
    fieldParser(k, parser) {
        this.parsers[k] = (v) => v == null ? v : parser(v);
        return this;
    }
    deserializeTemporalFields(o) {
        const result = Object.assign({}, o);
        Object.keys(this.parsers)
            .forEach(k => {
            result[k] = this.parsers[k](o[k]);
        });
        return result;
    }
    reviver(k, v) {
        if (v == null) {
            return v;
        }
        const parser = this.parsers[k];
        if (parser)
            return parser(v);
        return v;
    }
}
