import { JsonFetcher } from './json-fetcher';
import { delay, EMPTY, filter, map, Observable, retryWhen, share, shareReplay, switchMap, take } from 'rxjs';
import { resolveTemplate } from '@northtech/ginnungagap';
import { ensureLeadingQuestionmark, toQueryString } from './url-tools';
export class RestFetcher extends JsonFetcher {
    constructor(config) {
        super(config);
        const itemUrlTemplate = config.itemUrlTemplate;
        this.itemUrlTemplate = typeof itemUrlTemplate === 'string'
            ? new Observable((subscriber) => subscriber.next(itemUrlTemplate))
            : itemUrlTemplate.pipe(shareReplay(1));
        const collectionUrlTemplate = config.listUrlTemplate;
        this.listUrlTemplate = typeof collectionUrlTemplate === 'string'
            ? new Observable((subscriber) => subscriber.next(collectionUrlTemplate))
            : collectionUrlTemplate.pipe(shareReplay(1));
        this.GETRetryMillis = config.GETRetryMillis == null ? 30000 : config.GETRetryMillis;
    }
    get(id) {
        return this.itemUrlTemplate.pipe(take(1), switchMap(urlTemplate => this.fetchJson(resolveTemplate(urlTemplate, id, true))
            .pipe(retryWhen(err => this.GETRetryMillis > 0
            ? err.pipe(delay(this.GETRetryMillis))
            : EMPTY))), map(res => res.item));
    }
    // It bothers me that we'll have to send a dummy parameter in most cases to be allowed to use the query parameter,
    // but there is no real way to recognize whether a record-y object is meant as path params or query params.
    list(pathParams, query) {
        return this.listUrlTemplate.pipe(take(1), switchMap(urlTemplate => this.fetchJsonList(resolveTemplate(urlTemplate, pathParams, true) + ensureLeadingQuestionmark(toQueryString(query)))
            .pipe(retryWhen(err => this.GETRetryMillis > 0
            ? err.pipe(delay(this.GETRetryMillis))
            : EMPTY))), map(res => res.items));
    }
    put(item) {
        const obs = this.itemUrlTemplate.pipe(take(1), switchMap(urlTemplate => this.fetchJson(resolveTemplate(urlTemplate, item, true), { method: 'PUT', body: item })), map(res => res.item), share());
        obs.subscribe({
            error: () => {
                // Suppress console errors from this anonymous listener
            }
        });
        return obs;
    }
    post(item) {
        const obs = this.listUrlTemplate.pipe(take(1), switchMap(urlTemplate => this.fetchJson(resolveTemplate(urlTemplate, item, true), { method: 'POST', body: item })), map(res => res.item), share());
        obs.subscribe({
            error: () => {
                // Suppress console errors from this anonymous listener
            }
        });
        return obs;
    }
    delete(id) {
        const obs = this.itemUrlTemplate.pipe(take(1), switchMap(urlTemplate => this.fetchJson(resolveTemplate(urlTemplate, id, true), { method: 'DELETE' })), filter(_ => false), share());
        obs.subscribe({
            error: () => {
                // Suppress console errors from this anonymous listener
            }
        });
        return obs;
    }
}
