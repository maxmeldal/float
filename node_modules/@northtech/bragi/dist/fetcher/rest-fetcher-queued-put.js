var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _a, _RestFetcherQueuedPut_prefix, _RestFetcherQueuedPut_idRunner, _RestFetcherQueuedPut_uploaded;
import { BehaviorSubject, finalize, Subject, take } from 'rxjs';
import { isNotUndefined, resolveTemplate } from '@northtech/ginnungagap';
import { RestFetcher } from './rest-fetcher';
export class RestFetcherQueuedPut extends RestFetcher {
    constructor(config) {
        super(config);
        _RestFetcherQueuedPut_prefix.set(this, 'upload-' + this.constructor.name);
        this.queuedWrites = new BehaviorSubject(0);
        _RestFetcherQueuedPut_uploaded.set(this, new Subject());
        this.uploaded = __classPrivateFieldGet(this, _RestFetcherQueuedPut_uploaded, "f").asObservable();
        setInterval(() => this.tick(), (config.queuedPUTRetryMillis && config.queuedPUTRetryMillis > 0) ? config.queuedPUTRetryMillis : 30000);
    }
    queuePut(item) {
        this.itemUrlTemplate.pipe(take(1))
            .subscribe(urlTemplate => {
            const url = resolveTemplate(urlTemplate, item, true);
            const body = this.jsonConverter.objectToString(item);
            this.queueInternal({ url, method: 'PUT', body });
            this.tick();
        });
    }
    queueInternal(uploadEntry) {
        var _b, _c;
        try {
            window.localStorage.setItem(__classPrivateFieldGet(this, _RestFetcherQueuedPut_prefix, "f") + (__classPrivateFieldSet(_b = RestFetcherQueuedPut, _a, (_c = __classPrivateFieldGet(_b, _a, "f", _RestFetcherQueuedPut_idRunner), ++_c), "f", _RestFetcherQueuedPut_idRunner)), JSON.stringify(uploadEntry));
        }
        catch (error) {
            this.doUpload(undefined, uploadEntry);
        }
    }
    doUpload(key, uploadEntry) {
        RestFetcherQueuedPut.inflightUploads.next(RestFetcherQueuedPut.inflightUploads.value + 1);
        this.fetchJson(uploadEntry.url, { method: uploadEntry.method, body: uploadEntry.body })
            .pipe(finalize(() => {
            RestFetcherQueuedPut.inflightUploads.next(RestFetcherQueuedPut.inflightUploads.value - 1);
            if (key) {
                window.localStorage.removeItem(key);
            }
        }))
            .subscribe({
            next: res => __classPrivateFieldGet(this, _RestFetcherQueuedPut_uploaded, "f").next(res.item),
            error: _ => {
                // Move the upload data to the end of queue to prevent it from blocking other uploads:
                this.queueInternal(uploadEntry);
            },
            complete: () => {
                // Queue the next tick for immediate execution, rather than waiting for the normal schedule.
                // (Queueing rather than calling it directly allows the current call stack to complete, including running
                // finalizers).
                setTimeout(() => this.tick(), 0);
            }
        });
    }
    tick() {
        if (RestFetcherQueuedPut.inflightUploads.value === 0) {
            const uploadKey = this.nextUploadKey();
            if (uploadKey) {
                const jsonEntry = window.localStorage.getItem(uploadKey);
                if (jsonEntry != null) {
                    let upload;
                    try {
                        upload = JSON.parse(jsonEntry);
                    }
                    catch (err) {
                        // We could not parse the JSON. Nothing can recover from that, so delete the entry;
                        console.error('Incorrect JSON in localStorage. Removing upload item ', uploadKey, jsonEntry, err);
                        window.localStorage.removeItem(uploadKey);
                    }
                    if (upload != null) {
                        this.doUpload(uploadKey, upload);
                    }
                }
            }
        }
    }
    queuedItems() {
        return Object.keys(window.localStorage)
            .filter(s => s.startsWith(__classPrivateFieldGet(this, _RestFetcherQueuedPut_prefix, "f")))
            .map(key => {
            const jsonEntry = window.localStorage.getItem(key);
            if (jsonEntry == null)
                return undefined;
            try {
                return JSON.parse(jsonEntry);
            }
            catch (err) {
                // Ignore the error here and let the normal tick deal with it:
                return undefined;
            }
        })
            .filter(isNotUndefined)
            .map(entry => this.jsonConverter.stringToObject(entry.body))
            .filter(isNotUndefined);
    }
    nextUploadKey() {
        const uploads = Object.keys(window.localStorage)
            .filter(s => s.startsWith(__classPrivateFieldGet(this, _RestFetcherQueuedPut_prefix, "f")));
        this.queuedWrites.next(uploads.length);
        return uploads.sort((a, b) => this.keyToNumber(a) - this.keyToNumber(b))[0];
    }
    keyToNumber(k) {
        return parseInt(k.substring(__classPrivateFieldGet(this, _RestFetcherQueuedPut_prefix, "f").length), 10);
    }
}
_a = RestFetcherQueuedPut, _RestFetcherQueuedPut_prefix = new WeakMap(), _RestFetcherQueuedPut_uploaded = new WeakMap();
_RestFetcherQueuedPut_idRunner = { value: Date.now() };
RestFetcherQueuedPut.inflightUploads = new BehaviorSubject(0);
