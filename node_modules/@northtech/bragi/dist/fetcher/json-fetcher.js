import { RewritingFetcher } from './rewriting-fetcher';
import { JsonConverter } from '../json';
import { BehaviorSubject, EMPTY, finalize, from, switchMap } from 'rxjs';
export class JsonFetcher extends RewritingFetcher {
    constructor(config) {
        super(config);
        this.inflightReads = new BehaviorSubject(0);
        this.inflightWrites = new BehaviorSubject(0);
        this.error = new BehaviorSubject(undefined);
        this.jsonConverter = (config === null || config === void 0 ? void 0 : config.jsonConverter)
            ? config.jsonConverter
            : new JsonConverter();
        this.errorJsonConverter = (config === null || config === void 0 ? void 0 : config.errorJsonConverter)
            ? config.errorJsonConverter
            : new JsonConverter();
    }
    fetchJson(url, typedRequestInit) {
        return this.fetchJsonInternal(url, false, typedRequestInit);
    }
    fetchJsonList(url, typedRequestInit) {
        return this.fetchJsonInternal(url, true, typedRequestInit);
    }
    fetchJsonInternal(url, list, typedRequestInit) {
        const body = ((typedRequestInit === null || typedRequestInit === void 0 ? void 0 : typedRequestInit.body) != null)
            ? (typeof typedRequestInit.body === 'string' ? typedRequestInit.body : this.jsonConverter.objectToString(typedRequestInit.body))
            : undefined;
        const requestInit = Object.assign(Object.assign({}, typedRequestInit), { body, headers: Object.assign(Object.assign({}, typedRequestInit === null || typedRequestInit === void 0 ? void 0 : typedRequestInit.headers), { 'Accept': 'application/json', 'Content-Type': 'application/json' }) });
        const inflightTracker = this.getInflightTracker(requestInit);
        inflightTracker.next(inflightTracker.value + 1);
        return this.fetch(url, requestInit).pipe(finalize(() => inflightTracker.next(inflightTracker.value - 1)), switchMap(res => {
            if (res.status === 204 || res.status === 205 || res.status === 304) {
                this.error.next(undefined);
                // The server is explicitly not sending any data. In the context of a JSON fetch, the most reasonable
                // interpretation is "completed successfully, with no object delivered".
                return EMPTY;
            }
            else if (res.status >= 200 && res.status < 300) {
                this.error.next(undefined);
                return from(res.text()
                    .then(json => list ? ({
                    response: res,
                    items: this.jsonConverter.stringToArray(json)
                })
                    : ({
                        response: res,
                        item: this.jsonConverter.stringToObject(json)
                    })));
            }
            // Anything but the 200 range is, in the context of fetching a JSON object, an error.
            // (And even then, many of the 2xx codes are of questionable use).
            return from(this.parseError(res)
                .then(e => {
                this.error.next(e);
                throw e;
            }));
        }));
    }
    parseError(response) {
        return response.text()
            .then(text => {
            let error = undefined;
            let errorString = undefined;
            try {
                error = this.errorJsonConverter.stringToObject(text);
            }
            catch (e) {
                errorString = text;
            }
            return new HttpError(response, error, errorString);
        });
    }
    getInflightTracker(requestInit) {
        const method = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.method) == null ? 'GET' : requestInit.method.toUpperCase();
        return method === 'PUT' || method === 'POST' || method === 'DELETE'
            ? this.inflightWrites
            : this.inflightReads;
    }
}
export class HttpError extends Error {
    constructor(response, error, errorString) {
        super(response.status + ' - ' + response.url + (errorString ? (' - ' + errorString) : '') + (error ? (' - ' + JSON.stringify(error)) : ''));
        this.response = response;
        this.error = error;
        this.errorString = errorString;
        // Practically, we gain very little from a stack trace at this point.
        /*
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        */
        this.name = this.constructor.name;
    }
}
