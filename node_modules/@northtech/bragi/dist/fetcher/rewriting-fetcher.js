import { BehaviorSubject, filter, finalize, from, isObservable, ReplaySubject, share, switchMap, take } from 'rxjs';
import { isNotUndefined } from '@northtech/ginnungagap';
/**
 * A default implementation of a {@link RequestRewriter} which doesn't manipulate the request at all.
 */
export const ANONYMOUS = o => o;
/**
 * A default implementation of a {@link RequestRewriter} which always throws an {@link Aborted} error. (E.g. if the user
 * has not logged in yet, and all attempts to contact a server endpoint should be denied).
 */
export const ABORT = o => {
    throw new Aborted(o);
};
/**
 * An error subclass intended to be used by the {@link RequestRewriter} to signal that the request was deliberately
 * aborted.
 */
export class Aborted extends Error {
    constructor(request) {
        super();
        this.request = request;
    }
}
export function setHeader(request, name, value) {
    var _a;
    const headers = Object.assign(Object.assign({}, (_a = request.requestInit) === null || _a === void 0 ? void 0 : _a.headers), { [name]: value });
    return ({
        url: request.url,
        requestInit: Object.assign(Object.assign({}, request.requestInit), { headers })
    });
}
export function setHeaders(request, headers) {
    var _a;
    const h = Object.assign(Object.assign({}, (_a = request.requestInit) === null || _a === void 0 ? void 0 : _a.headers), headers);
    return ({
        url: request.url,
        requestInit: Object.assign(Object.assign({}, request.requestInit), { headers: h })
    });
}
/**
 * The `RewritingFetcher` is a fairly thin layer around the native `fetch` method, allowing asynchronous manipulation of
 * the request before it is sent. The primary motivation is adding authorization headers, likely based on a refresh
 * token, but the rewriter can in principle manipulate the request in any way.
 */
export class RewritingFetcher {
    constructor(config) {
        this.requestRewriters = new ReplaySubject(1);
        this.requestRewriters.next(prioritizeRewriters(config === null || config === void 0 ? void 0 : config.requestRewriters));
    }
    /**
     * A RequestRewriter _must_ be set (even if just the do-nothing {@link ANONYMOUS} rewriter) before a server can be
     * contacted. (The Fetcher cannot make assumptions and default to an anonymous access attempt, since we do not want
     * to spam requests to a server which requires login before the login rewriter is ready).
     */
    setRequestRewriter(requestRewriters) {
        this.requestRewriters.next(prioritizeRewriters(requestRewriters));
        return this;
    }
    fetch(requestOrUrl, requestInit) {
        let request;
        if (typeof requestOrUrl === 'string') {
            request = { url: requestOrUrl, requestInit };
        }
        else {
            request = requestOrUrl;
        }
        const obs = this.requestRewriters.pipe(filter(isNotUndefined), take(1), switchMap(rewriters => {
            const rewritten = pickRewriter(request, rewriters)(request);
            return isObservable(rewritten)
                ? rewritten.pipe(take(1))
                : from(Promise.resolve(rewritten));
        }), switchMap(req => {
            const inflightTracker = RewritingFetcher.getInflightTracker(request.requestInit);
            inflightTracker.next(inflightTracker.value + 1);
            return from(fetch(req.url, req.requestInit))
                .pipe(finalize(() => inflightTracker.next(inflightTracker.value - 1)));
        }), share());
        // Make sure the fetch actually fires regardless of client listeners, to obey the principle of least astonishment
        obs.subscribe({
            error: () => {
                // Suppress console errors from this anonymous listener
            }
        });
        return obs;
    }
    static getInflightTracker(requestInit) {
        const method = (requestInit === null || requestInit === void 0 ? void 0 : requestInit.method) == null ? 'GET' : requestInit.method.toUpperCase();
        return method === 'PUT' || method === 'POST' || method === 'DELETE'
            ? RewritingFetcher.inflightWrites
            : RewritingFetcher.inflightReads;
    }
}
RewritingFetcher.inflightReads = new BehaviorSubject(0);
RewritingFetcher.inflightWrites = new BehaviorSubject(0);
function pickRewriter(request, rewriters) {
    var _a, _b, _c;
    const method = ((_c = (_b = (_a = request.requestInit) === null || _a === void 0 ? void 0 : _a.method) === null || _b === void 0 ? void 0 : _b.toUpperCase()) !== null && _c !== void 0 ? _c : 'GET');
    const rewriter = rewriters[method];
    if (!rewriter)
        throw new Error('No RequestRewriter given for method ' + method);
    return rewriter;
}
function prioritizeRewriters(rewriters) {
    if (rewriters == null)
        return undefined;
    return {
        GET: rewriters.GET != null ? rewriters.GET : rewriters.ALL,
        PUT: rewriters.PUT != null ? rewriters.PUT : (rewriters.ALL_WRITES != null ? rewriters.ALL_WRITES : rewriters.ALL),
        POST: rewriters.POST != null ? rewriters.POST : (rewriters.ALL_WRITES != null ? rewriters.ALL_WRITES : rewriters.ALL),
        PATCH: rewriters.PATCH != null ? rewriters.PATCH : (rewriters.ALL_WRITES != null ? rewriters.ALL_WRITES : rewriters.ALL),
        DELETE: rewriters.DELETE != null ? rewriters.DELETE : (rewriters.ALL_WRITES != null ? rewriters.ALL_WRITES : rewriters.ALL)
    };
}
