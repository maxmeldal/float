var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _LoggerBase_observers, _LoggerBase_entry, _LoggerBase_idRunner;
import { Observable } from 'rxjs';
/**
 * @experimental
 *
 * The generic type `COMPONENT_NAMES` can be used to restrict the possible component names. At heart, it is just a string
 * (and it's fully valid to create a `Logger<string>`), but to enforce consistency, you can implement it as a union type
 * of specific strings, e.g. `Logger<'network' | 'login' | 'unknown'>`.
 */
export class LoggerBase extends Observable {
    constructor() {
        super((observer => {
            // Replay current value to new subscribers:
            if (__classPrivateFieldGet(this, _LoggerBase_entry, "f")) {
                observer.next(__classPrivateFieldGet(this, _LoggerBase_entry, "f"));
            }
            __classPrivateFieldGet(this, _LoggerBase_observers, "f").add(observer);
            // Teardown logic on unsubscription:
            return () => {
                __classPrivateFieldGet(this, _LoggerBase_observers, "f").delete(observer);
            };
        }));
        _LoggerBase_observers.set(this, new Set());
        _LoggerBase_entry.set(this, void 0);
        _LoggerBase_idRunner.set(this, 0);
    }
    debug(component, message, detailObjectOrError, error) {
        this.log('DEBUG', component, message, detailObjectOrError, error);
    }
    info(component, message, detailObjectOrError, error) {
        this.log('INFO', component, message, detailObjectOrError, error);
    }
    warn(component, message, detailObjectOrError, error) {
        this.log('WARN', component, message, detailObjectOrError, error);
    }
    error(component, message, detailObjectOrError, error) {
        this.log('ERROR', component, message, detailObjectOrError, error);
    }
    log(level, component, message, detailObjectOrError, error) {
        var _a;
        let traceObject;
        if (error) {
            traceObject = detailObjectOrError;
        }
        else if (detailObjectOrError instanceof Error) {
            error = detailObjectOrError;
        }
        else {
            traceObject = detailObjectOrError;
        }
        const entry = {
            id: __classPrivateFieldSet(this, _LoggerBase_idRunner, (_a = __classPrivateFieldGet(this, _LoggerBase_idRunner, "f"), ++_a), "f"),
            level,
            component,
            message,
            detailObject: traceObject,
            error,
            timestampMillis: Date.now()
        };
        __classPrivateFieldGet(this, _LoggerBase_observers, "f").forEach(obs => obs.next(entry));
    }
}
_LoggerBase_observers = new WeakMap(), _LoggerBase_entry = new WeakMap(), _LoggerBase_idRunner = new WeakMap();
