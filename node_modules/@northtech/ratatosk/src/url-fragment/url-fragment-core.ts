import { Observable, ReplaySubject, share } from 'rxjs';
import { filter, finalize, map, tap } from 'rxjs/operators';

/**
 * This is the internal core of the hash fragment/deeplink functionality.
 * You probably want the browser-enabled {@link UrlFragment} instance exported from <code>url-fragment</code>.
 */
// Having the core logic separated from the I/O events driving it makes it easily testable.
export class UrlFragmentCore {
  /**
   * A stream of key-value params picked up from the URL fragment.
   * Be aware that the maps in this class handle decoded keys (to ensure correct comparison),
   * but encoded values (to be able to parse them into different output formats later).
   */
  private readonly parameters = new ReplaySubject<Map<string, string>>(1);
  private readonly paramWatches = new Map<string, Observable<string | undefined>>();
  // We track the "known" parameters as parsed from the URL:
  private readonly knownParameters = new Map<string, string>();
  // Rather than using ".distinctUntilChanged", we track distinct ourselves,
  // to be able to suppress events triggered by our own .set(...)
  private readonly distinctParams = new Map<string, string>();

  /**
   * @param {(s: string) => void} hashSetter A function which will be called when the UrlFragmentCore wants to set the
   * hash in the browser.
   */
  constructor(private readonly hashSetter: (s: string) => void) {
  }

  /**
   * To be called when the hash fragment in the browser URL changes.
   * (This is automatically set up in {@link UrlFragment})
   */
  parse(hashFragment: string): void {
    this.parseHashToKnownParameters(hashFragment);
    this.parameters.next(this.knownParameters);
  }

  /**
   * Returns an observable which will emit when the given key changes in the URL hash fragment.
   */
  watch(key: string): Observable<string | undefined> {
    return this.watchEncoded(key)
      .pipe(
        map(v => v === undefined ? undefined : decodeURIComponent(v))
      );
  }

  watchNumber(key: string): Observable<number | undefined> {
    return this.watchEncoded(key)
      .pipe(
        map(s => (s === undefined || s === '')
          ? undefined
          : parseFloat(decodeURIComponent(s)))
      );
  }

  watchArray(key: string): Observable<string[] | undefined> {
    return this.watchEncoded(key)
      .pipe(
        map(v => v === undefined
          ? undefined
          : v.split(';').map(s => decodeURIComponent(s)))
      );
  }

  watchNumberArray(key: string): Observable<number[] | undefined> {
    return this.watchEncoded(key)
      .pipe(
        map(v => v === undefined
          ? undefined
          : v.split(';').map(s => parseFloat(decodeURIComponent(s))))
      );
  }

  /**
   * Setting a value in the hash fragment does <i>not</i> emit a corresponding value in the Observable from the
   * {@link UrlFragment#watch} methods. This is deliberate, to prevent accidental feedback loops, and to avoid that
   * the hash fragment is used as a component-to-component communications channel.
   * It is best to think of the URL fragment as a storage which a service/component can use to store and re-establish
   * its own state, not as a messaging system to other components.
   * As a (very strong) rule of thumb, a component should not <code>set</code> anything that it doesn't itself <code>watch</code>.
   */
  set(key: string, value: string | number | (string | number)[] | undefined): UrlFragmentCore {
    if (value == null) {
      this.knownParameters.delete(key);
      this.distinctParams.delete(key);
    } else {
      value = Array.isArray(value)
        ? value.map(v => encodeURIComponent(v.toString())).join(';')
        : encodeURIComponent(value.toString());

      this.knownParameters.set(key, value);
      this.distinctParams.set(key, value);
    }
    this.hashSetter(this.generateHash());
    return this;
  }

  private parseHashToKnownParameters(hash: string): void {
    while (hash.startsWith('#')) {
      hash = hash.substring(1);
    }
    this.knownParameters.clear();
    hash.split('&')
      .map(kvp => kvp.split('=', 2))
      .filter(kvp => kvp[1] !== undefined)
      .forEach(kvp => this.knownParameters.set(decodeURIComponent(kvp[0]), kvp[1]));
  }

  private watchEncoded(key: string): Observable<string | undefined> {
    let paramWatch = this.paramWatches.get(key);
    if (paramWatch === undefined) {
      paramWatch = this.parameters
        .pipe(
          map(params => params.get(key)),
          filter(value => value !== this.distinctParams.get(key)),
          tap(value => {
            if (value === undefined) {
              this.distinctParams.delete(key);
            } else {
              this.distinctParams.set(key, value);
            }
          }),
          // Remove the shared Observable from the hashmap once all subscribers unsubscribe:
          finalize(() => {
            this.paramWatches.delete(key);
            this.distinctParams.delete(key);
          }),
          share({
            connector: () => new ReplaySubject(1),
            resetOnRefCountZero: true,
            resetOnComplete: true,
            resetOnError: true
          })
        );
      this.paramWatches.set(key, paramWatch);
    }
    return paramWatch;
  }

  private generateHash(): string {
    const hash: string[] = [];
    this.knownParameters.forEach((value, key) => hash.push(encodeURIComponent(key) + '=' + value));
    return '#' + hash.join('&');
  }
}
