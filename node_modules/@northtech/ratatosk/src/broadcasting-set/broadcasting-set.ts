import * as deepEqual from 'fast-deep-equal/es6';
import { Subject } from 'rxjs';
import { ElementChange, ElementChangeCreateUpdate } from './element-change';
import { map } from 'rxjs/operators';

/**
 * A BroadcastingSet maintains a set of elements identified by an ID, and exposes Observables signaling changes to the
 * elements.
 *
 * **Note**: If the ID of an object is changed after it is inserted into a BroadcastingSet, the behavior of the set is
 * undefined.
 *
 * The methods in this class typically return the same object which is also emitted in {@link changes}. In most cases,
 * you should not use this, as relying on the synchronous return value in a specific part of the code rather defeats
 * the purpose of the BroadcastingSet in the first place.
 *
 * The return types may seem a little inconsistent, sometimes being Arrays and sometimes being IterableIterator. This is
 * because the class internally uses Maps and typically simply exposes IterableIterators directly from those maps. In
 * many cases, an iterator is enough for the purpose, so converting it to an Array for "niceness" would be an
 * unnecessary performance hit. Conversely, sometimes the class needs to work with an array internally, and in those
 * cases exposes it as such.
 */
export class BroadcastingSet<ElementT, IdT> {
  private readonly elementMap: Map<IdT, ElementT> = new Map<IdT, ElementT>();

  readonly #changeMessages = new Subject<ElementChange<ElementT, IdT>>();
  /**
   * A stream of {@link ElementChange}s describing the changes to the BroadcastingSet as they happen. A change message
   * is triggered _after_ the BroadcastingSet has been updated, _before_ changes are signaled in {@link elements}.
   * If a bulk operations ({@link putAll} or {@link replaceAll}) does multiple updates to the same element ID, only one
   * change will be reported, ignoring the intermediate updates and reporting the initial and final value.
   */
  readonly changes = this.#changeMessages.asObservable();

  private readonly emitTrigger = new Subject<boolean>();
  /**
   * An Observable of the items in the BroadcastingSet, emitting every time the values change. A change message will
   * only be emitted once for each of the bulk operations, {@link putAll}, {@link replaceAll} and {@link clear}.
   * The value is an {@link IterableIterator} which can be stepped through using the for...of construct. If you need it
   * as an array, simply use `Array.from(...)`.
   */
  readonly elements = this.emitTrigger.pipe(map(this.elementMap.values));

  /**
   * @param idExtractor A function which converts an element to its id. The types of this function implicitly determines
   * the type of the BroadcastingSet.
   * @param equality When putting elements into the set, changes will only be reported if the elements actually differ.
   * By default, elements will be compared using fast-deep-equal, but in some cases, the elements may already carry,
   * say, a revision number or change date which can be used for fast identification. In such cases, provide an equality
   * function leveraging that.
   */
  constructor(
    private readonly idExtractor: (element: ElementT) => IdT,
    private equality = (a: ElementT, b: ElementT) => deepEqual(a, b)
  ) {
  }

  private createChange(id: IdT, previousElement: ElementT | undefined, newElement: ElementT): ElementChangeCreateUpdate<ElementT, IdT> | undefined;
  private createChange(id: IdT, previousElement: ElementT | undefined, newElement: ElementT | undefined): ElementChange<ElementT, IdT> | undefined;
  private createChange(id: IdT, previousElement: ElementT | undefined, newElement: ElementT | undefined): ElementChange<ElementT, IdT> | undefined {
    if (previousElement != null && newElement != null && !this.equality(previousElement, newElement)) {
      return {
        type: 'UPDATE',
        id: id,
        previousValue: previousElement,
        newValue: newElement
      };
    }
    if (previousElement == null && newElement != null) {
      return {
        type: 'CREATE',
        id: id,
        newValue: newElement
      };
    }
    if (previousElement != null && newElement == null) {
      return {
        type: 'DELETE',
        id: id,
        previousValue: previousElement
      };
    }
    return undefined;
  }

  /**
   * Inserts an element into the set, adding it if the ID does not already exist, or updating it if it does.
   * This will trigger a change message in {@link changes} (if the new object differs from the existing, per the
   * equality function given to the {@link BroadcastingSet:constructor}.
   */
  put(element: ElementT): ElementChange<ElementT, IdT> | undefined {
    const id = this.idExtractor(element);
    const previous = this.elementMap.get(id);
    const change = this.createChange(id, previous, element);
    if (change) {
      this.elementMap.set(change.id, change.newValue);
      this.#changeMessages.next(change);
      this.emitTrigger.next(true);
    }
    return change;
  }

  /**
   * Inserts multiple elements. Change messages will be emitted for each in {@link changes}, but the {@link elements}
   * will only emit once (if the insertions resulted in any actual changes).
   */
  putAll(elements: Iterable<ElementT>): IterableIterator<ElementChange<ElementT, IdT>> {
    const changes = this.scanForCreateOrUpdates(elements);
    if (changes.size) {
      this.emitTrigger.next(true);
    }
    return changes.values();
  }

  /**
   * Replaces all elements in the set with those given, emitting delete, create and update messages as appropriate,
   * depending on what was already in the set.
   */
  replaceAll(elements: Iterable<ElementT>): ElementChange<ElementT, IdT>[] {
    const knownNewIds = new Set<IdT>();
    for (const element of elements) {
      knownNewIds.add(this.idExtractor(element));
    }
    const deleteChanges: ElementChange<ElementT, IdT>[] = [];
    // Scan through existing elements:
    this.elementMap.forEach((element, id) => {
      if (!knownNewIds.has(id)) {
        this.elementMap.delete(id);
        // Hardcode the delete message, since we have all information:
        let elementChange: ElementChange<ElementT, IdT>;
        deleteChanges.push(elementChange = {
          type: 'DELETE',
          id,
          previousValue: element
        });
        // And fire it:
        this.#changeMessages.next(elementChange);
      }
    });
    // Find all create or update:
    const putChanges = this.scanForCreateOrUpdates(elements);
    // Signal updates to the list:
    if (deleteChanges.length > 0 || putChanges.size > 0) {
      this.emitTrigger.next(true);
    }

    deleteChanges.push(...putChanges.values());
    return deleteChanges;
  }

  private scanForCreateOrUpdates(elements: Iterable<ElementT>): Map<IdT, ElementChangeCreateUpdate<ElementT, IdT>> {
    const changes = new Map<IdT, ElementChangeCreateUpdate<ElementT, IdT>>();
    for (const element of elements) {
      const id = this.idExtractor(element);
      const previousChange = changes.get(id);
      const previousElement = previousChange != null
        ? previousChange.previousValue
        : this.elementMap.get(id);
      // Multiple changes can flip the value back to the original, which should not be reported as a change.
      // So we delete the change registry, and recreate it as needed.
      // This has the additional benefit of ensuring that changes are inserted at the end, so the order of the change
      // report is consistent with the (final) changes it reports. Hence, deleting before (re)inserting:
      changes.delete(id);
      const change = this.createChange(id, previousElement, element);
      if (change) {
        changes.set(id, change);
      }
    }
    for (const change of changes.values()) {
      this.elementMap.set(change.id, change.newValue);
      this.#changeMessages.next(change);
    }
    return changes;
  }

  /**
   * Removes a specific element from the set, emitting a delete message if the element existed.
   */
  remove(id: IdT): ElementChange<ElementT, IdT> | undefined {
    const previous = this.elementMap.get(id);
    const change = this.createChange(id, previous, undefined);
    if (change) {
      this.elementMap.delete(change.id);
      this.emitTrigger.next(true);
      this.#changeMessages.next(change);
    }
    return change;
  }

  /**
   * Removes all elements from the set, emitting delete messages for each.
   */
  clear(): ElementChange<ElementT, IdT>[] {
    return Array.from(
      this.elementMap.entries(), ([id, element]) => {
        const change: ElementChange<ElementT, IdT> = {
          type: 'DELETE',
          id: id,
          previousValue: element
        };
        this.elementMap.delete(id);
        this.#changeMessages.next(change);
        return change;
      }
    );
  }
}

