import { Observable, Observer, Subscription } from 'rxjs';
import { finalize } from 'rxjs/operators';

/**
 * PartialObject is an Observable of an object which can be filled out with values one by one, emitting as each
 * property changes. This is particularly useful for assembling a configuration object from multiple (asynchronous)
 * sources.
 */
export class PartialObject<T /* extends { [key: string]: string | number | boolean | undefined | null } */>
  extends Observable<Partial<T>> {
  readonly #data: Partial<T> = {};
  readonly #observers = new Set<Observer<Partial<T>>>();

  readonly #binds = new Map<keyof T, Observable<any>>();
  readonly #subscriptions = new Map<keyof T, Subscription>();

  constructor() {
    super((observer: Observer<Partial<T>>) => {
      const prevSize = this.#observers.size;
      this.#observers.add(observer);
      if (prevSize === 0 && this.#observers.size === 1) {
        this.#binds.forEach((v, k) => {
          this.#subscriptions.set(k, v
            .pipe(finalize(() => {
              this.#subscriptions.delete(k);
            }))
            .subscribe(o => this.set(k, o)));
        });
      }
      if (Object.keys(this.#data).length) {
        observer.next({...this.#data});
      }
      return () => {
        this.#observers.delete(observer);
        if (this.#observers.size === 0) {
          this.#subscriptions.forEach(sub => sub.unsubscribe());
        }
      };
    });
  }

  /**
   * Binds one property of the object to an Observable delivering the appropriate type, making the PartialObject update
   * and emit each time a new value arrives on the bound Observable.
   *
   * *Note*: In many cases (especially when using data from a terminating Observable, such as a HTTP call), it is
   * probably more readable to simply subscribe to the Observable and set the received value using {@link set} or
   * {@link setAll}. The advantage of using this `.bind` method is that it keeps the bound observable "cold", and only
   * subscribes to it if there are subscribers to the PartialObject itself.
   *
   * @param k The name of a key in the PartialObject (based on its generic type).
   * @param v An Observable of the appropriate type (or null/undefined).
   */
  bind<U extends keyof T>(k: U, v: Observable<T[U] | undefined | null> | undefined): this {
    const sub = this.#subscriptions.get(k);
    if (sub) {
      sub.unsubscribe();
    }
    this.#binds.delete(k);

    if (v) {
      this.#binds.set(k, v);
      if (this.#observers.size) {
        this.#subscriptions.set(k, v
          .pipe(finalize(() => {
            this.#subscriptions.delete(k);
          }))
          .subscribe(o => this.set(k, o)));
      }
    }
    return this;
  }

  /**
   * Sets all the given properties in the PartialObject and emits of there are any changes.
   */
  setAll(o: Partial<T>): this {
    let changed = false;
    (Object.keys(o) as any).forEach((k: keyof T) => {
      const v = o[k];
      if (v == null) {
        changed = changed || (this.#data[k] != null);
        delete this.#data[k];
      } else {
        changed = changed || (this.#data[k] !== v);
        this.#data[k] = v;
      }
    });
    if (changed) {
      const emit: Partial<T> = {...this.#data};
      this.#observers.forEach(o => o.next(emit));
    }
    return this;
  }

  /**
   * Sets the given property in the PartialObject and emits of there are any changes.
   */
  set<U extends keyof T>(k: U, v: T[U] | undefined | null): this {
    let changed: boolean;
    if (v == null) {
      changed = (this.#data[k] != null);
      delete this.#data[k];
    } else {
      changed = (this.#data[k] !== v);
      this.#data[k] = v;
    }
    if (changed) {
      const emit: Partial<T> = {...this.#data};
      this.#observers.forEach(o => o.next(emit));
    }
    return this;
  }
}
