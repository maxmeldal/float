import { map, Observable, Observer, pairwise, startWith, SubscriptionLike, takeUntil } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';
import { deepEquals } from './deep-equals';
import { DeepReadonly, PickKeys, Writable } from 'ts-essentials';
import structuredClone from 'core-js/actual/structured-clone';

/**
 * An `ObservableStore` maintains data of generic type `StoreDataT`, providing methods to set the fields, in turn
 * emitting values on requested `Observable`s. The values are emitted as read-only objects to prevent manipulation of
 * the internal data structure, though it is also possible to request a deep clone of the objects.
 *
 * The `ObservableStore` can write its state to LocalStorage, making it possible to easily recreate the application
 * state when reloading the app.
 *
 * (The `ObservableStore` is itself an `Observable` of type `StoreDataT`, acting like a `BehaviorSubject`,
 * maintaining a single value and replaying it to new subscribers).
 *
 * @example
 *     interface ApplicationData {
 *       name: string;
 *       count: number;
 *     }
 *     const applicationState = new ObservableStore<ApplicationData>({
 *       name: 'Initial value',
 *       count: 0
 *     });
 *     applicationState.observe('name').subscribe(value => console.log(value));
 *     applicationState.set('name', 'New name');
 */
export class ObservableStore<StoreDataT> extends Observable<StoreDataT> {
  #localStoragePrefix = 'ObservableStore$';
  #data: StoreDataT;
  #observers = new Set<Observer<StoreDataT>>();
  #serializers: { [K in keyof StoreDataT]?: (value: StoreDataT[K]) => string } = {};
  #deserializers: { [K in keyof StoreDataT]?: (json: string) => StoreDataT[K] } = {};

  /**
   * @param initialValue A valid instance of type `StoreDataT`, serving as the initial value of the data.
   * @param fieldsToPersist An object describing which fields in the store data to persist in localStorage. The object
   * consists of keys matching the keys in `StoreDataTÂ´, with either a boolean value (true if the value should be
   * persisted as standard JSON), or an object with custom serializer/deserializers for the field.
   * @param storeNamespace If given, will be used when storing state in LocalStorage. This allows an app to use more
   * than one `ObservableStore` without their values colliding.
   *
   * @example
   *     new ObservableStore<TestObject>(
   *       {a: 'A', b: 1},
   *       {
   *         a: {serializer: v => JSON.stringify(v), deserializer: json => JSON.parse(json)},
   *         b: true
   *       }
   *     );
   */
  constructor(initialValue: StoreDataT,
              fieldsToPersist?: { [K in keyof StoreDataT]?: boolean | { serializer?: (value: StoreDataT[K]) => string, deserializer?: (json: string) => StoreDataT[K] } },
              storeNamespace?: string) {
    super((observer => {
      // Replay current value to new subscribers:
      observer.next(this.#data);
      this.#observers.add(observer);
      // Teardown logic on unsubscription:
      return () => {
        this.#observers.delete(observer);
      };
    }));
    this.#data = {...initialValue};

    if (fieldsToPersist) {
      const storePrefix = storeNamespace?.trim();
      if (storePrefix) {
        this.#localStoragePrefix = 'ObservableStore-' + storePrefix + '$';
      }

      (Object.keys(fieldsToPersist) as (keyof StoreDataT)[])
        .forEach(k => {
          const serialization = fieldsToPersist[k];
          if (serialization === true) {
            this.#serializers[k] = JSON.stringify;
            this.#deserializers[k] = JSON.parse;
          } else if (typeof serialization === 'object') {
            this.#serializers[k] = serialization.serializer ? serialization.serializer : JSON.stringify;
            this.#deserializers[k] = serialization.deserializer ? serialization.deserializer : JSON.parse;
          }
        });

      // A little housekeeping, cleaning up old, now untracked fields so we don't accumulate debris in the localStorage:
      const trackedFields = Object.keys(this.#deserializers).map(k => this.#localStoragePrefix + k);
      Object.keys(localStorage)
        .filter(key => key.startsWith(this.#localStoragePrefix))
        .forEach(key => {
          if (!trackedFields.includes(key)) {
            localStorage.removeItem(key);
          }
        });

      (Object.keys(this.#deserializers) as (keyof StoreDataT)[]).forEach(key => {
        try {
          const storedJson = localStorage.getItem(this.#localStoragePrefix + key);
          if (storedJson != null) {
            const storedValue = this.#deserializers[key]?.(storedJson);
            if (storedValue != null) {
              this.#data[key] = storedValue;
            }
          }
        } catch (e) {
          console.log('Error when restoring ' + key + ' from localStorage', e);
        }
      });
    }
  }

  /**
   * Returns the current value of the internal data.
   */
  getValue(): DeepReadonly<StoreDataT> {
    return this.#data as any;
  }

  /**
   * Sets a given field to a given value. If the new value is not equal to the current value, it will trigger a
   * notification in the relevant `Observable`s. (See {@link observe})
   * @param key The name of the field. Must be a field in type `StoreDataT`
   * @param value The new value. Must be of the appropriate type.
   */
  set<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, value: DeepReadonly<StoreDataT[KeyInStoreT]>): void;
  /**
   * Sets several fields at once. If any of the new values are not equal to the current value, it will trigger a
   * notification in the relevant `Observable`s. (See {@link observe})
   * @param keyValueObject An object containing key/value pairs to set. The object must be a subset (`Pick`) of type `StoreDataT`
   */
  set<KeyInStoreT extends keyof StoreDataT>(keyValueObject: DeepReadonly<Pick<StoreDataT, KeyInStoreT>>): void;
  set<KeyInStoreT extends keyof StoreDataT>(keyOrKeyValueObject: KeyInStoreT | DeepReadonly<Pick<StoreDataT, KeyInStoreT>>, value?: DeepReadonly<StoreDataT[KeyInStoreT]>): void {
    if (typeof keyOrKeyValueObject === 'object') {
      this.setObject(keyOrKeyValueObject as any);
    } else {
      // The implementing signature technically allows for v to be undefined, but the exposed signatures do not, so we
      // simply assert it:
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      this.setValue(keyOrKeyValueObject as any, value! as any);
    }
  }

  private setValue<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, value: StoreDataT[KeyInStoreT]): void {
    const changed = !deepEquals(this.#data[key], value);
    this.#data[key] = value;
    this.persist(key, value);
    if (changed) {
      this.notifyObservers();
    }
  }

  private setObject<KeyInStoreT extends keyof StoreDataT>(keyValueObject: Pick<StoreDataT, KeyInStoreT>): void {
    let changed = false;
    // We lose the typed tuples when going through the plain string keys, but the parameter type ensures that the
    // objects are compatible, so we just assert:
    (Object.keys(keyValueObject) as (KeyInStoreT)[]).forEach(k => {
      changed = changed || !deepEquals(this.#data[k], [k]);
      this.#data[k] = keyValueObject[k];
      this.persist(k, keyValueObject[k]);
    });
    if (changed) {
      this.notifyObservers();
    }
  }

  private persist<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, value: StoreDataT[KeyInStoreT]): void {
    const serializer = this.#serializers[key];
    if (serializer) {
      try {
        const json = serializer(value);
        if (json == null) {
          localStorage.removeItem(this.#localStoragePrefix + key);
        } else {
          localStorage.setItem(this.#localStoragePrefix + key, json);
        }
      } catch (e) {
        console.log('error when storing ' + key, value, e);
      }
    }
  }

  /*
  private sameObject(a: any, b: any): boolean {
    return typeof a === 'object' && a != null ? a === b : false;
  }
  */

  /**
   * Returns an `Observable` which emits the values for the given key as they are updated.
   *
   * If an observed field is of an object type, e.g. `MyInterface`, the returned value will be of utility type
   * `DeepReadonly<MyInterface>`. (If the returned object was not immutable, it would be possible to manipulate the
   * internal state of the ObservableStore by reference without triggering change notifications).
   *
   * This is essentially a shorthand for
   *
   *     observableStore.pipe(
   *       map(data => {
   *         const o = data.key;
   *         return o as DeepReadonly<typeof o>;
   *       }),
   *       distinctUntilChanged((a, b) => deepEquals(a, b))
   *     );
   */
  observe<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT): Observable<DeepReadonly<StoreDataT[KeyInStoreT]>>;

  /**
   * Returns an `Observable` of an object consisting of the specified fields.
   *
   * If an observed field is of an object type, e.g. `MyInterface`, the returned value will be of utility type
   * `DeepReadonly<MyInterface>`. (If the returned object was not immutable, it would be possible to manipulate the
   * internal state of the ObservableStore by reference without triggering change notifications).
   *
   * This is essentially a shorthand for
   *
   *     observableStore.pipe(
   *       map(data => {
   *         const o = {
   *           k1: data.k1,
   *           k2: data.k2
   *         };
   *         return o as DeepReadonly<typeof o>;
   *       }),
   *       distinctUntilChanged((a, b) => deepEquals(a, b))
   *     );
   */
  observe<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, ...additionalKeys: KeyInStoreT[]): Observable<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>>;

  /**
   * Returns an `Observable` of an object consisting of the specified fields, given as an array.
   *
   * If an observed field is of an object type, e.g. `MyInterface`, the returned value will be of utility type
   * `DeepReadonly<MyInterface>`. (If the returned object was not immutable, it would be possible to manipulate the
   * internal state of the ObservableStore by reference without triggering change notifications).
   *
   * This is equivalent to
   *
   *     observableStore.pipe(
   *       map(data => {
   *         const o = {
   *           k1: data.k1,
   *           k2: data.k2
   *         };
   *         return o as DeepReadonly<typeof o>;
   *       }),
   *       distinctUntilChanged((a, b) => deepEquals(a, b))
   *     );
   */
  observe<KeyInStoreT extends keyof StoreDataT>(keys: KeyInStoreT[]): Observable<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>>;
  observe<KeyInStoreT extends keyof StoreDataT>(keyOrKeys: KeyInStoreT | KeyInStoreT[], ...additionalKeys: KeyInStoreT[]): Observable<DeepReadonly<StoreDataT[KeyInStoreT]>> | Observable<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>> {
    let input: KeyInStoreT | KeyInStoreT[];
    if (additionalKeys.length > 0) {
      input = Array.isArray(keyOrKeys)
        ? [...keyOrKeys, ...additionalKeys]
        : [keyOrKeys, ...additionalKeys];
    } else {
      input = keyOrKeys;
    }
    if (Array.isArray(input)) {
      // We just claim the result to be DeepReadonly to tell the using code "hands off!"
      return this.observeObject(...input) as any;
    } else {
      return this.observeValue(input) as any;
    }
  }

  /**
   * As {@link observe}, but instead of returning DeepReadonly objects, it returns a deep clone (using structuredClone).
   * This means you're free to manipulate the returned object without violating the immutability of the ObservableStore.
   */
  observeClone<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT): Observable<StoreDataT[KeyInStoreT]>;
  /**
   * As {@link observe}, but instead of returning DeepReadonly objects, it returns a deep clone (using structuredClone).
   * This means you're free to manipulate the returned object without violating the immutability of the ObservableStore.
   */
  observeClone<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, ...additionalKeys: KeyInStoreT[]): Observable<Pick<StoreDataT, KeyInStoreT>>;
  /**
   * As {@link observe}, but instead of returning DeepReadonly objects, it returns a deep clone (using structuredClone).
   * This means you're free to manipulate the returned object without violating the immutability of the ObservableStore.
   */
  observeClone<KeyInStoreT extends keyof StoreDataT>(keys: KeyInStoreT[]): Observable<Pick<StoreDataT, KeyInStoreT>>;
  observeClone<KeyInStoreT extends keyof StoreDataT>(keyOrKeys: KeyInStoreT | KeyInStoreT[], ...additionalKeys: KeyInStoreT[]): Observable<StoreDataT[KeyInStoreT]> | Observable<Pick<StoreDataT, KeyInStoreT>> {
    let input: KeyInStoreT | KeyInStoreT[];
    if (additionalKeys.length > 0) {
      input = Array.isArray(keyOrKeys)
        ? [...keyOrKeys, ...additionalKeys]
        : [keyOrKeys, ...additionalKeys];
    } else {
      input = keyOrKeys;
    }
    if (Array.isArray(input)) {
      return this.observeObject(...input).pipe(map(o => structuredClone(o)));
    } else {
      return this.observeValue(input).pipe(map(o => structuredClone(o)));
    }
  }

  private observeValue<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT): Observable<StoreDataT[KeyInStoreT]> {
    return this.pipe(
      map(data => data[key]),
      distinctUntilChanged((a, b) => deepEquals(a, b))
    );
  }

  private observeObject<KeyInStoreT extends keyof StoreDataT>(...keys: KeyInStoreT[]): Observable<Pick<StoreDataT, KeyInStoreT>> {
    return this.pipe(
      map(data => {
          const o: Pick<StoreDataT, KeyInStoreT> = {} as any;
          keys.forEach(key => o[key] = data[key]);
          return o;
        }
      ),
      distinctUntilChanged((a, b) => deepEquals(a, b))
    );
  }

  /**
   * As {@link observe}, but emits a tuple of `[previous, current]` values. `previous` will be `undefined` at the first
   * emit.
   */
  observePairwise<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT):
    Observable<[
      previous: DeepReadonly<StoreDataT[KeyInStoreT]> | undefined,
      current: DeepReadonly<StoreDataT[KeyInStoreT]>
    ]>;
  /**
   * As {@link observe}, but emits a tuple of `[previous, current]` values. `previous` will be `undefined` at the first
   * emit.
   */
  observePairwise<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, ...additionalKeys: KeyInStoreT[]):
    Observable<[
      previous: DeepReadonly<Pick<StoreDataT, KeyInStoreT>> | undefined,
      current: DeepReadonly<Pick<StoreDataT, KeyInStoreT>>
    ]>;
  /**
   * As {@link observe}, but emits a tuple of `[previous, current]` values. `previous` will be `undefined` at the first
   * emit.
   */
  observePairwise<KeyInStoreT extends keyof StoreDataT>(keys: KeyInStoreT[]):
    Observable<[
      previous: DeepReadonly<Pick<StoreDataT, KeyInStoreT>> | undefined,
      current: DeepReadonly<Pick<StoreDataT, KeyInStoreT>>
    ]>;
  observePairwise<KeyInStoreT extends keyof StoreDataT>(keyOrKeys: KeyInStoreT | KeyInStoreT[], ...additionalKeys: KeyInStoreT[]):
    Observable<[
      previous: DeepReadonly<StoreDataT[KeyInStoreT]> | undefined,
      current: DeepReadonly<StoreDataT[KeyInStoreT]>
    ]>
    |
    Observable<[
      previous: DeepReadonly<Pick<StoreDataT, KeyInStoreT>> | undefined,
      current: DeepReadonly<Pick<StoreDataT, KeyInStoreT>>
    ]> {
    let input: KeyInStoreT | KeyInStoreT[];
    if (additionalKeys.length > 0) {
      input = Array.isArray(keyOrKeys)
        ? [...keyOrKeys, ...additionalKeys]
        : [keyOrKeys, ...additionalKeys];
    } else {
      input = keyOrKeys;
    }

    return (Array.isArray(input) ? this.observeObject(...input) : this.observeObject(input)
    ).pipe(
      startWith(undefined),
      pairwise()
    ) as any;
  }

  /**
   * Updates the ObservableStore based on the current values in the store. This is useful if you need functionality
   * such as "add an item to an existing array in the store". (Remember that the store values should be treated as
   * immutable, so in this example, you should `.concat` rather than `.push`).
   * @param updateFunction A function which takes the current data of the store and returns an object with a subset
   * (`Pick`) of the fields.
   * The calculated fields will be updated in the store, and any `Observables` will be triggered as if the values had
   * been set with {@link set}.
   * @returns A `DeepReadonly` version of the result of the update function; i.e. the same object which has been {@link set} in the store.
   */
  apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => DeepReadonly<Pick<StoreDataT, KeyInStoreT>>): DeepReadonly<Pick<StoreDataT, KeyInStoreT>>;

  /**
   * Updates the ObservableStore based on the current values in the store.
   * @param updateFunction A function which takes the current data of the store and returns an object with a subset
   * (`Partial`) of the fields. This is a looser typing than a `Pick`, in turn giving less information about the return
   * type. Also, if you do not use `exactOptionalPropertyTypes: true`, be careful not to break the types by explicitly
   * setting an `undefined` value in an optional field.
   * The calculated fields will be updated in the store, and any `Observables` will be triggered as if the values had
   * been set with {@link set}.
   * @returns A `DeepReadonly` version of the result of the update function; i.e. the same object which has been {@link set} in the store.
   */
  apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => DeepReadonly<Partial<StoreDataT>>): DeepReadonly<Partial<StoreDataT>>;
  /**
   * Updates the ObservableStore asynchronously based on the current values in the store. This is useful if you need functionality
   * such as "add an item to an existing array in the store". (Remember that the store values should be treated as
   * immutable, so in this example, you should `.concat` rather than `.push`).
   * @param updateFunction A function which takes the current data of the store and returns a `Promise` of a subset
   * (`Pick`) of the fields.
   * Once the `Promise` fulfills, the calculated fields will be updated in the store, and any `Observables` will
   * be triggered as if the values had been set with {@link set}.
   * @returns A `DeepReadonly` version of the result of the update function; i.e. the same `Promise`d object which will be {@link set} in the store.
   */
  apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => Promise<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>>): Promise<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>>;
  /**
   * Updates the ObservableStore asynchronously based on the current values in the store. This is useful if you need functionality
   * @param updateFunction A function which takes the current data of the store and returns a `Promise` of a subset
   * (`Partial`) of the fields. This is a looser typing than a `Pick`, in turn giving less information about the return
   * type. Also, if you do not use `exactOptionalPropertyTypes: true`, be careful not to break the types by explicitly
   * setting an `undefined` value in an optional field.
   * Once the `Promise` fulfills, the calculated fields will be updated in the store, and any `Observables` will
   * be triggered as if the values had been set with {@link set}.
   * @returns A `DeepReadonly` version of the result of the update function; i.e. the same `Promise`d object which will be {@link set} in the store.
   */
  apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => Promise<DeepReadonly<Partial<StoreDataT>>>): Promise<DeepReadonly<Partial<StoreDataT>>>;
  apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => DeepReadonly<Pick<StoreDataT, KeyInStoreT>> | DeepReadonly<Partial<StoreDataT>> | Promise<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>> | Promise<DeepReadonly<Partial<StoreDataT>>>): DeepReadonly<Pick<StoreDataT, KeyInStoreT>> | DeepReadonly<Partial<StoreDataT>> | Promise<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>> | Promise<DeepReadonly<Partial<StoreDataT>>> {
    const update = updateFunction(this.#data as DeepReadonly<StoreDataT>);
    // The "as any" here is because we let a Partial masquerade as a Pick. This is not strictly correct unless we
    // use exactOptionalPropertyTypes, and even then the compiler has a hard time typechecking it when dropping
    // through the index access we need to set fields.
    if (update instanceof Promise) {
      update.then(o => this.setObject(o as any));
    } else {
      this.setObject(update as any);
    }
    return update as any;
  }

  /**
   * Concats the given element to the list in field `key`, updating the value as per {@link set}
   */
  addToList<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, element: ArrayElement<StoreDataT[KeyInStoreT]>): void {
    // The key will refer to a list of the appropriate type, or the method signature would not have compiled:
    this.setValue(key, (this.#data as any)[key].concat(element));
  }

  /*
  // This saves too little at the cost of obscuring the Subscription
  reactTo<K extends keyof T, K2 extends keyof T>(...args: [...K[], (data: Observable<Pick<T, K>>) => Observable<Pick<T, K2>>]): Subscription {
    const updateFunction = args.pop() as (data: Observable<Pick<T, K>>) => Observable<Pick<T, K2>>;
    return updateFunction(this.observe(args as K[]))
      .subscribe(o => this.set(o));
  }
  */

  private notifyObservers() {
    this.#observers.forEach(obs => obs.next(this.#data));
  }

  /**
   * Angular-specific utility method binding a given `FormControl(Like)` to a key in the store. The `FormControl` will
   * be initialized with the current value in the store, and will then be kept in sync with the store, updating each
   * other as changes happen in one or the other.
   * @param key The store key to bind to.
   * @param formControl An Angular `FormControl`. It is assumed that the formControl values will be of the correct type
   * for the store.
   * @return A SubscriptionLike which must be used to unsubscribe the binding when the FormControl is disposed of.
   */
  bindToFormControl<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, formControl: FormControlLike): SubscriptionLike;
  /**
   * Angular-specific utility method binding a given `FormControl(Like)` to a key in the store. The `FormControl` will
   * be initialized with the current value in the store, and will then be kept in sync with the store, updating each
   * other as changes happen in one or the other.
   * @param key The store key to bind to.
   * @param formControl An Angular `FormControl`. It is assumed that the formControl values will be of the correct type
   * for the store.
   * @param until An `Observable` which signals when this binding should be disconnected. Typically, this will be an
   * `Observable` signaling when the Angular component is being destroyed.
   */
  bindToFormControl<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, formControl: FormControlLike, until: Observable<unknown>): void;
  // I am, on principle, not crazy about Angular-specific code creeping into the RxJs-based store, but by using a
  // minimalistic FormControlLike interface we avoid an actual dependency to Angular, and we can probably spare 30 lines
  // of code to support this common use case.
  bindToFormControl<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, formControl: FormControlLike, until?: Observable<unknown>): SubscriptionLike | void {
    if (until) {
      this.observe(key)
        .pipe(takeUntil(until))
        .subscribe(v => {
          if (!deepEquals(v, formControl.value)) {
            formControl.setValue(v);
          }
        });
      formControl.valueChanges
        .pipe(takeUntil(until))
        .subscribe(v => this.set(key, v));
      return;
    } else {
      const sub1 = this.observe(key)
        .subscribe(v => {
          if (!deepEquals(v, formControl.value)) {
            formControl.setValue(v);
          }
        });
      const sub2 = formControl.valueChanges
        .subscribe(v => this.set(key, v));
      const subscription: Writable<SubscriptionLike> = {
        closed: false,
        unsubscribe(): void {
          this.closed = true;
          sub1.unsubscribe();
          sub2.unsubscribe();
        }
      };
      return subscription;
    }
  }

  /**
   * Angular-specific utility method which sets the given keys from a ParamMap-like object in the store, restricted to
   * only the keys which are of type number, string or undefined in the `ObservableStore` (since they are the types
   * which can reliably be expressed in the route without needing custom deserialization).
   * @param params A `ParamMaplike` object, as obtained from Angular's ActivatedRoute.paramMap Observable.
   * @param keys The name of the keys to pick from the `ParamMap` and set in the `ObservableStore`.
   *
   * @example
   *
   *     ngOnInit(): void {
   *       this.activatedRoute.paramMap
   *         .subscribe(paramMap => this.applicationState.setParamMap(paramMap, 'wantedUserId'));
   *       ...
   */
  setParamMap<KeyInStoreT extends PickKeys<StoreDataT, string | number | undefined>>(
    params: ParamMapLike,
    ...keys: KeyInStoreT[])
    : Pick<StoreDataT, KeyInStoreT> {
    const o: any = {};
    for (const k of keys) {
      const stringK = k.toString();
      if (params.keys.includes(stringK)) {
        const v = params.get(stringK);
        if (v != null) {
          const parsed = parseInt(v, 10);
          o[k] = isNaN(parsed) ? v : parsed;
        } else {
          // I am a little unsure about how to handle undefined here. It seems dangerous to explicitly push into the
          // store, but we need it in the signature.
          o[k] = undefined;
        }
      } else {
        console.error('Required parameter ' + stringK + ' was not given in ParamMap. (Given router parameter names are ' + params.keys + ')');
      }
    }
    this.setObject(o);
    return o;
  }
}

export type ArrayElement<A> = A extends readonly (infer T)[] ? T : never;

export interface FormControlLike {
  readonly value: any;

  setValue(value: any): void;

  valueChanges: Observable<any>;
}

export interface ParamMapLike {
  readonly keys: string[];

  get(name: string): string | null | undefined;
}

/*
interface ApplicationData {
  name: string;
  count: number | undefined;
  else: { a: number } | undefined;
}

const applicationState = new ObservableStore<ApplicationData>({
  name: 'Initial value',
  count: 0,
  else: undefined
});
applicationState.observe('name').subscribe(value => console.log(value));
applicationState.set('name', 'New name');

const paramMap = {} as any;

applicationState.setParamMap(paramMap, 'count');

/*
interface Test {
  k1: string;
  k2: number | undefined;
  k3: number[];
}

const observableStore = new ObservableStore<Test>({k1: 'yay', k2: 1, k3: [1, 2, 3]});

observableStore.observePairwise(['k1', 'k2'])
  .pipe(
    map(([prev, curr]) => console.log(prev, curr))
  );

const immutable: DeepReadonly<Test> = {
  k1: 'test',
  k2: 2,
  k3: [4, 5, 6]
};

observableStore.observe('k1', 'k2')
  .subscribe(data => {
    observableStore.set(data);
  });

observableStore.set(immutable);

observableStore.pipe(
  map(data => {
    const o = {
      k1: data.k1,
      k2: data.k2
    };
    return o as DeepReadonly<typeof o>;
  }),
  distinctUntilChanged((a, b) => deepEquals(a, b))
);

observableStore.pipe(
  map(data => {
    const o = data.k1;
    return o as DeepReadonly<typeof o>;
  }),
  distinctUntilChanged((a, b) => deepEquals(a, b))
);
*/
