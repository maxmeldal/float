var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BroadcastingSet_changeMessages;
import * as deepEqual from 'fast-deep-equal/es6';
import { Subject } from 'rxjs';
import { map } from 'rxjs/operators';
/**
 * A BroadcastingSet maintains a set of elements identified by an ID, and exposes Observables signaling changes to the
 * elements.
 *
 * **Note**: If the ID of an object is changed after it is inserted into a BroadcastingSet, the behavior of the set is
 * undefined.
 *
 * The methods in this class typically return the same object which is also emitted in {@link changes}. In most cases,
 * you should not use this, as relying on the synchronous return value in a specific part of the code rather defeats
 * the purpose of the BroadcastingSet in the first place.
 *
 * The return types may seem a little inconsistent, sometimes being Arrays and sometimes being IterableIterator. This is
 * because the class internally uses Maps and typically simply exposes IterableIterators directly from those maps. In
 * many cases, an iterator is enough for the purpose, so converting it to an Array for "niceness" would be an
 * unnecessary performance hit. Conversely, sometimes the class needs to work with an array internally, and in those
 * cases exposes it as such.
 */
export class BroadcastingSet {
    /**
     * @param idExtractor A function which converts an element to its id. The types of this function implicitly determines
     * the type of the BroadcastingSet.
     * @param equality When putting elements into the set, changes will only be reported if the elements actually differ.
     * By default, elements will be compared using fast-deep-equal, but in some cases, the elements may already carry,
     * say, a revision number or change date which can be used for fast identification. In such cases, provide an equality
     * function leveraging that.
     */
    constructor(idExtractor, equality = (a, b) => deepEqual(a, b)) {
        this.idExtractor = idExtractor;
        this.equality = equality;
        this.elementMap = new Map();
        _BroadcastingSet_changeMessages.set(this, new Subject());
        /**
         * A stream of {@link ElementChange}s describing the changes to the BroadcastingSet as they happen. A change message
         * is triggered _after_ the BroadcastingSet has been updated, _before_ changes are signaled in {@link elements}.
         * If a bulk operations ({@link putAll} or {@link replaceAll}) does multiple updates to the same element ID, only one
         * change will be reported, ignoring the intermediate updates and reporting the initial and final value.
         */
        this.changes = __classPrivateFieldGet(this, _BroadcastingSet_changeMessages, "f").asObservable();
        this.emitTrigger = new Subject();
        /**
         * An Observable of the items in the BroadcastingSet, emitting every time the values change. A change message will
         * only be emitted once for each of the bulk operations, {@link putAll}, {@link replaceAll} and {@link clear}.
         * The value is an {@link IterableIterator} which can be stepped through using the for...of construct. If you need it
         * as an array, simply use `Array.from(...)`.
         */
        this.elements = this.emitTrigger.pipe(map(this.elementMap.values));
    }
    createChange(id, previousElement, newElement) {
        if (previousElement != null && newElement != null && !this.equality(previousElement, newElement)) {
            return {
                type: 'UPDATE',
                id: id,
                previousValue: previousElement,
                newValue: newElement
            };
        }
        if (previousElement == null && newElement != null) {
            return {
                type: 'CREATE',
                id: id,
                newValue: newElement
            };
        }
        if (previousElement != null && newElement == null) {
            return {
                type: 'DELETE',
                id: id,
                previousValue: previousElement
            };
        }
        return undefined;
    }
    /**
     * Inserts an element into the set, adding it if the ID does not already exist, or updating it if it does.
     * This will trigger a change message in {@link changes} (if the new object differs from the existing, per the
     * equality function given to the {@link BroadcastingSet:constructor}.
     */
    put(element) {
        const id = this.idExtractor(element);
        const previous = this.elementMap.get(id);
        const change = this.createChange(id, previous, element);
        if (change) {
            this.elementMap.set(change.id, change.newValue);
            __classPrivateFieldGet(this, _BroadcastingSet_changeMessages, "f").next(change);
            this.emitTrigger.next(true);
        }
        return change;
    }
    /**
     * Inserts multiple elements. Change messages will be emitted for each in {@link changes}, but the {@link elements}
     * will only emit once (if the insertions resulted in any actual changes).
     */
    putAll(elements) {
        const changes = this.scanForCreateOrUpdates(elements);
        if (changes.size) {
            this.emitTrigger.next(true);
        }
        return changes.values();
    }
    /**
     * Replaces all elements in the set with those given, emitting delete, create and update messages as appropriate,
     * depending on what was already in the set.
     */
    replaceAll(elements) {
        const knownNewIds = new Set();
        for (const element of elements) {
            knownNewIds.add(this.idExtractor(element));
        }
        const deleteChanges = [];
        // Scan through existing elements:
        this.elementMap.forEach((element, id) => {
            if (!knownNewIds.has(id)) {
                this.elementMap.delete(id);
                // Hardcode the delete message, since we have all information:
                let elementChange;
                deleteChanges.push(elementChange = {
                    type: 'DELETE',
                    id,
                    previousValue: element
                });
                // And fire it:
                __classPrivateFieldGet(this, _BroadcastingSet_changeMessages, "f").next(elementChange);
            }
        });
        // Find all create or update:
        const putChanges = this.scanForCreateOrUpdates(elements);
        // Signal updates to the list:
        if (deleteChanges.length > 0 || putChanges.size > 0) {
            this.emitTrigger.next(true);
        }
        deleteChanges.push(...putChanges.values());
        return deleteChanges;
    }
    scanForCreateOrUpdates(elements) {
        const changes = new Map();
        for (const element of elements) {
            const id = this.idExtractor(element);
            const previousChange = changes.get(id);
            const previousElement = previousChange != null
                ? previousChange.previousValue
                : this.elementMap.get(id);
            // Multiple changes can flip the value back to the original, which should not be reported as a change.
            // So we delete the change registry, and recreate it as needed.
            // This has the additional benefit of ensuring that changes are inserted at the end, so the order of the change
            // report is consistent with the (final) changes it reports. Hence, deleting before (re)inserting:
            changes.delete(id);
            const change = this.createChange(id, previousElement, element);
            if (change) {
                changes.set(id, change);
            }
        }
        for (const change of changes.values()) {
            this.elementMap.set(change.id, change.newValue);
            __classPrivateFieldGet(this, _BroadcastingSet_changeMessages, "f").next(change);
        }
        return changes;
    }
    /**
     * Removes a specific element from the set, emitting a delete message if the element existed.
     */
    remove(id) {
        const previous = this.elementMap.get(id);
        const change = this.createChange(id, previous, undefined);
        if (change) {
            this.elementMap.delete(change.id);
            this.emitTrigger.next(true);
            __classPrivateFieldGet(this, _BroadcastingSet_changeMessages, "f").next(change);
        }
        return change;
    }
    /**
     * Removes all elements from the set, emitting delete messages for each.
     */
    clear() {
        return Array.from(this.elementMap.entries(), ([id, element]) => {
            const change = {
                type: 'DELETE',
                id: id,
                previousValue: element
            };
            this.elementMap.delete(id);
            __classPrivateFieldGet(this, _BroadcastingSet_changeMessages, "f").next(change);
            return change;
        });
    }
}
_BroadcastingSet_changeMessages = new WeakMap();
