import { ElementChange } from './element-change';
/**
 * A BroadcastingSet maintains a set of elements identified by an ID, and exposes Observables signaling changes to the
 * elements.
 *
 * **Note**: If the ID of an object is changed after it is inserted into a BroadcastingSet, the behavior of the set is
 * undefined.
 *
 * The methods in this class typically return the same object which is also emitted in {@link changes}. In most cases,
 * you should not use this, as relying on the synchronous return value in a specific part of the code rather defeats
 * the purpose of the BroadcastingSet in the first place.
 *
 * The return types may seem a little inconsistent, sometimes being Arrays and sometimes being IterableIterator. This is
 * because the class internally uses Maps and typically simply exposes IterableIterators directly from those maps. In
 * many cases, an iterator is enough for the purpose, so converting it to an Array for "niceness" would be an
 * unnecessary performance hit. Conversely, sometimes the class needs to work with an array internally, and in those
 * cases exposes it as such.
 */
export declare class BroadcastingSet<ElementT, IdT> {
    #private;
    private readonly idExtractor;
    private equality;
    private readonly elementMap;
    /**
     * A stream of {@link ElementChange}s describing the changes to the BroadcastingSet as they happen. A change message
     * is triggered _after_ the BroadcastingSet has been updated, _before_ changes are signaled in {@link elements}.
     * If a bulk operations ({@link putAll} or {@link replaceAll}) does multiple updates to the same element ID, only one
     * change will be reported, ignoring the intermediate updates and reporting the initial and final value.
     */
    readonly changes: import("rxjs").Observable<ElementChange<ElementT, IdT>>;
    private readonly emitTrigger;
    /**
     * An Observable of the items in the BroadcastingSet, emitting every time the values change. A change message will
     * only be emitted once for each of the bulk operations, {@link putAll}, {@link replaceAll} and {@link clear}.
     * The value is an {@link IterableIterator} which can be stepped through using the for...of construct. If you need it
     * as an array, simply use `Array.from(...)`.
     */
    readonly elements: import("rxjs").Observable<IterableIterator<ElementT>>;
    /**
     * @param idExtractor A function which converts an element to its id. The types of this function implicitly determines
     * the type of the BroadcastingSet.
     * @param equality When putting elements into the set, changes will only be reported if the elements actually differ.
     * By default, elements will be compared using fast-deep-equal, but in some cases, the elements may already carry,
     * say, a revision number or change date which can be used for fast identification. In such cases, provide an equality
     * function leveraging that.
     */
    constructor(idExtractor: (element: ElementT) => IdT, equality?: (a: ElementT, b: ElementT) => boolean);
    private createChange;
    /**
     * Inserts an element into the set, adding it if the ID does not already exist, or updating it if it does.
     * This will trigger a change message in {@link changes} (if the new object differs from the existing, per the
     * equality function given to the {@link BroadcastingSet:constructor}.
     */
    put(element: ElementT): ElementChange<ElementT, IdT> | undefined;
    /**
     * Inserts multiple elements. Change messages will be emitted for each in {@link changes}, but the {@link elements}
     * will only emit once (if the insertions resulted in any actual changes).
     */
    putAll(elements: Iterable<ElementT>): IterableIterator<ElementChange<ElementT, IdT>>;
    /**
     * Replaces all elements in the set with those given, emitting delete, create and update messages as appropriate,
     * depending on what was already in the set.
     */
    replaceAll(elements: Iterable<ElementT>): ElementChange<ElementT, IdT>[];
    private scanForCreateOrUpdates;
    /**
     * Removes a specific element from the set, emitting a delete message if the element existed.
     */
    remove(id: IdT): ElementChange<ElementT, IdT> | undefined;
    /**
     * Removes all elements from the set, emitting delete messages for each.
     */
    clear(): ElementChange<ElementT, IdT>[];
}
