import { Observable, SubscriptionLike } from 'rxjs';
import { DeepReadonly, PickKeys } from 'ts-essentials';
/**
 * An `ObservableStore` maintains data of generic type `StoreDataT`, providing methods to set the fields, in turn
 * emitting values on requested `Observable`s. The values are emitted as read-only objects to prevent manipulation of
 * the internal data structure, though it is also possible to request a deep clone of the objects.
 *
 * The `ObservableStore` can write its state to LocalStorage, making it possible to easily recreate the application
 * state when reloading the app.
 *
 * (The `ObservableStore` is itself an `Observable` of type `StoreDataT`, acting like a `BehaviorSubject`,
 * maintaining a single value and replaying it to new subscribers).
 *
 * @example
 *     interface ApplicationData {
 *       name: string;
 *       count: number;
 *     }
 *     const applicationState = new ObservableStore<ApplicationData>({
 *       name: 'Initial value',
 *       count: 0
 *     });
 *     applicationState.observe('name').subscribe(value => console.log(value));
 *     applicationState.set('name', 'New name');
 */
export declare class ObservableStore<StoreDataT> extends Observable<StoreDataT> {
    #private;
    /**
     * @param initialValue A valid instance of type `StoreDataT`, serving as the initial value of the data.
     * @param fieldsToPersist An object describing which fields in the store data to persist in localStorage. The object
     * consists of keys matching the keys in `StoreDataTÂ´, with either a boolean value (true if the value should be
     * persisted as standard JSON), or an object with custom serializer/deserializers for the field.
     * @param storeNamespace If given, will be used when storing state in LocalStorage. This allows an app to use more
     * than one `ObservableStore` without their values colliding.
     *
     * @example
     *     new ObservableStore<TestObject>(
     *       {a: 'A', b: 1},
     *       {
     *         a: {serializer: v => JSON.stringify(v), deserializer: json => JSON.parse(json)},
     *         b: true
     *       }
     *     );
     */
    constructor(initialValue: StoreDataT, fieldsToPersist?: {
        [K in keyof StoreDataT]?: boolean | {
            serializer?: (value: StoreDataT[K]) => string;
            deserializer?: (json: string) => StoreDataT[K];
        };
    }, storeNamespace?: string);
    /**
     * Returns the current value of the internal data.
     */
    getValue(): DeepReadonly<StoreDataT>;
    /**
     * Sets a given field to a given value. If the new value is not equal to the current value, it will trigger a
     * notification in the relevant `Observable`s. (See {@link observe})
     * @param key The name of the field. Must be a field in type `StoreDataT`
     * @param value The new value. Must be of the appropriate type.
     */
    set<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, value: DeepReadonly<StoreDataT[KeyInStoreT]>): void;
    /**
     * Sets several fields at once. If any of the new values are not equal to the current value, it will trigger a
     * notification in the relevant `Observable`s. (See {@link observe})
     * @param keyValueObject An object containing key/value pairs to set. The object must be a subset (`Pick`) of type `StoreDataT`
     */
    set<KeyInStoreT extends keyof StoreDataT>(keyValueObject: DeepReadonly<Pick<StoreDataT, KeyInStoreT>>): void;
    private setValue;
    private setObject;
    private persist;
    /**
     * Returns an `Observable` which emits the values for the given key as they are updated.
     *
     * If an observed field is of an object type, e.g. `MyInterface`, the returned value will be of utility type
     * `DeepReadonly<MyInterface>`. (If the returned object was not immutable, it would be possible to manipulate the
     * internal state of the ObservableStore by reference without triggering change notifications).
     *
     * This is essentially a shorthand for
     *
     *     observableStore.pipe(
     *       map(data => {
     *         const o = data.key;
     *         return o as DeepReadonly<typeof o>;
     *       }),
     *       distinctUntilChanged((a, b) => deepEquals(a, b))
     *     );
     */
    observe<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT): Observable<DeepReadonly<StoreDataT[KeyInStoreT]>>;
    /**
     * Returns an `Observable` of an object consisting of the specified fields.
     *
     * If an observed field is of an object type, e.g. `MyInterface`, the returned value will be of utility type
     * `DeepReadonly<MyInterface>`. (If the returned object was not immutable, it would be possible to manipulate the
     * internal state of the ObservableStore by reference without triggering change notifications).
     *
     * This is essentially a shorthand for
     *
     *     observableStore.pipe(
     *       map(data => {
     *         const o = {
     *           k1: data.k1,
     *           k2: data.k2
     *         };
     *         return o as DeepReadonly<typeof o>;
     *       }),
     *       distinctUntilChanged((a, b) => deepEquals(a, b))
     *     );
     */
    observe<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, ...additionalKeys: KeyInStoreT[]): Observable<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>>;
    /**
     * Returns an `Observable` of an object consisting of the specified fields, given as an array.
     *
     * If an observed field is of an object type, e.g. `MyInterface`, the returned value will be of utility type
     * `DeepReadonly<MyInterface>`. (If the returned object was not immutable, it would be possible to manipulate the
     * internal state of the ObservableStore by reference without triggering change notifications).
     *
     * This is equivalent to
     *
     *     observableStore.pipe(
     *       map(data => {
     *         const o = {
     *           k1: data.k1,
     *           k2: data.k2
     *         };
     *         return o as DeepReadonly<typeof o>;
     *       }),
     *       distinctUntilChanged((a, b) => deepEquals(a, b))
     *     );
     */
    observe<KeyInStoreT extends keyof StoreDataT>(keys: KeyInStoreT[]): Observable<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>>;
    /**
     * As {@link observe}, but instead of returning DeepReadonly objects, it returns a deep clone (using structuredClone).
     * This means you're free to manipulate the returned object without violating the immutability of the ObservableStore.
     */
    observeClone<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT): Observable<StoreDataT[KeyInStoreT]>;
    /**
     * As {@link observe}, but instead of returning DeepReadonly objects, it returns a deep clone (using structuredClone).
     * This means you're free to manipulate the returned object without violating the immutability of the ObservableStore.
     */
    observeClone<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, ...additionalKeys: KeyInStoreT[]): Observable<Pick<StoreDataT, KeyInStoreT>>;
    /**
     * As {@link observe}, but instead of returning DeepReadonly objects, it returns a deep clone (using structuredClone).
     * This means you're free to manipulate the returned object without violating the immutability of the ObservableStore.
     */
    observeClone<KeyInStoreT extends keyof StoreDataT>(keys: KeyInStoreT[]): Observable<Pick<StoreDataT, KeyInStoreT>>;
    private observeValue;
    private observeObject;
    /**
     * As {@link observe}, but emits a tuple of `[previous, current]` values. `previous` will be `undefined` at the first
     * emit.
     */
    observePairwise<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT): Observable<[
        previous: DeepReadonly<StoreDataT[KeyInStoreT]> | undefined,
        current: DeepReadonly<StoreDataT[KeyInStoreT]>
    ]>;
    /**
     * As {@link observe}, but emits a tuple of `[previous, current]` values. `previous` will be `undefined` at the first
     * emit.
     */
    observePairwise<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, ...additionalKeys: KeyInStoreT[]): Observable<[
        previous: DeepReadonly<Pick<StoreDataT, KeyInStoreT>> | undefined,
        current: DeepReadonly<Pick<StoreDataT, KeyInStoreT>>
    ]>;
    /**
     * As {@link observe}, but emits a tuple of `[previous, current]` values. `previous` will be `undefined` at the first
     * emit.
     */
    observePairwise<KeyInStoreT extends keyof StoreDataT>(keys: KeyInStoreT[]): Observable<[
        previous: DeepReadonly<Pick<StoreDataT, KeyInStoreT>> | undefined,
        current: DeepReadonly<Pick<StoreDataT, KeyInStoreT>>
    ]>;
    /**
     * Updates the ObservableStore based on the current values in the store. This is useful if you need functionality
     * such as "add an item to an existing array in the store". (Remember that the store values should be treated as
     * immutable, so in this example, you should `.concat` rather than `.push`).
     * @param updateFunction A function which takes the current data of the store and returns an object with a subset
     * (`Pick`) of the fields.
     * The calculated fields will be updated in the store, and any `Observables` will be triggered as if the values had
     * been set with {@link set}.
     * @returns A `DeepReadonly` version of the result of the update function; i.e. the same object which has been {@link set} in the store.
     */
    apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => DeepReadonly<Pick<StoreDataT, KeyInStoreT>>): DeepReadonly<Pick<StoreDataT, KeyInStoreT>>;
    /**
     * Updates the ObservableStore based on the current values in the store.
     * @param updateFunction A function which takes the current data of the store and returns an object with a subset
     * (`Partial`) of the fields. This is a looser typing than a `Pick`, in turn giving less information about the return
     * type. Also, if you do not use `exactOptionalPropertyTypes: true`, be careful not to break the types by explicitly
     * setting an `undefined` value in an optional field.
     * The calculated fields will be updated in the store, and any `Observables` will be triggered as if the values had
     * been set with {@link set}.
     * @returns A `DeepReadonly` version of the result of the update function; i.e. the same object which has been {@link set} in the store.
     */
    apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => DeepReadonly<Partial<StoreDataT>>): DeepReadonly<Partial<StoreDataT>>;
    /**
     * Updates the ObservableStore asynchronously based on the current values in the store. This is useful if you need functionality
     * such as "add an item to an existing array in the store". (Remember that the store values should be treated as
     * immutable, so in this example, you should `.concat` rather than `.push`).
     * @param updateFunction A function which takes the current data of the store and returns a `Promise` of a subset
     * (`Pick`) of the fields.
     * Once the `Promise` fulfills, the calculated fields will be updated in the store, and any `Observables` will
     * be triggered as if the values had been set with {@link set}.
     * @returns A `DeepReadonly` version of the result of the update function; i.e. the same `Promise`d object which will be {@link set} in the store.
     */
    apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => Promise<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>>): Promise<DeepReadonly<Pick<StoreDataT, KeyInStoreT>>>;
    /**
     * Updates the ObservableStore asynchronously based on the current values in the store. This is useful if you need functionality
     * @param updateFunction A function which takes the current data of the store and returns a `Promise` of a subset
     * (`Partial`) of the fields. This is a looser typing than a `Pick`, in turn giving less information about the return
     * type. Also, if you do not use `exactOptionalPropertyTypes: true`, be careful not to break the types by explicitly
     * setting an `undefined` value in an optional field.
     * Once the `Promise` fulfills, the calculated fields will be updated in the store, and any `Observables` will
     * be triggered as if the values had been set with {@link set}.
     * @returns A `DeepReadonly` version of the result of the update function; i.e. the same `Promise`d object which will be {@link set} in the store.
     */
    apply<KeyInStoreT extends keyof StoreDataT>(updateFunction: (storeData: DeepReadonly<StoreDataT>) => Promise<DeepReadonly<Partial<StoreDataT>>>): Promise<DeepReadonly<Partial<StoreDataT>>>;
    /**
     * Concats the given element to the list in field `key`, updating the value as per {@link set}
     */
    addToList<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, element: ArrayElement<StoreDataT[KeyInStoreT]>): void;
    private notifyObservers;
    /**
     * Angular-specific utility method binding a given `FormControl(Like)` to a key in the store. The `FormControl` will
     * be initialized with the current value in the store, and will then be kept in sync with the store, updating each
     * other as changes happen in one or the other.
     * @param key The store key to bind to.
     * @param formControl An Angular `FormControl`. It is assumed that the formControl values will be of the correct type
     * for the store.
     * @return A SubscriptionLike which must be used to unsubscribe the binding when the FormControl is disposed of.
     */
    bindToFormControl<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, formControl: FormControlLike): SubscriptionLike;
    /**
     * Angular-specific utility method binding a given `FormControl(Like)` to a key in the store. The `FormControl` will
     * be initialized with the current value in the store, and will then be kept in sync with the store, updating each
     * other as changes happen in one or the other.
     * @param key The store key to bind to.
     * @param formControl An Angular `FormControl`. It is assumed that the formControl values will be of the correct type
     * for the store.
     * @param until An `Observable` which signals when this binding should be disconnected. Typically, this will be an
     * `Observable` signaling when the Angular component is being destroyed.
     */
    bindToFormControl<KeyInStoreT extends keyof StoreDataT>(key: KeyInStoreT, formControl: FormControlLike, until: Observable<unknown>): void;
    /**
     * Angular-specific utility method which sets the given keys from a ParamMap-like object in the store, restricted to
     * only the keys which are of type number, string or undefined in the `ObservableStore` (since they are the types
     * which can reliably be expressed in the route without needing custom deserialization).
     * @param params A `ParamMaplike` object, as obtained from Angular's ActivatedRoute.paramMap Observable.
     * @param keys The name of the keys to pick from the `ParamMap` and set in the `ObservableStore`.
     *
     * @example
     *
     *     ngOnInit(): void {
     *       this.activatedRoute.paramMap
     *         .subscribe(paramMap => this.applicationState.setParamMap(paramMap, 'wantedUserId'));
     *       ...
     */
    setParamMap<KeyInStoreT extends PickKeys<StoreDataT, string | number | undefined>>(params: ParamMapLike, ...keys: KeyInStoreT[]): Pick<StoreDataT, KeyInStoreT>;
}
export declare type ArrayElement<A> = A extends readonly (infer T)[] ? T : never;
export interface FormControlLike {
    readonly value: any;
    setValue(value: any): void;
    valueChanges: Observable<any>;
}
export interface ParamMapLike {
    readonly keys: string[];
    get(name: string): string | null | undefined;
}
