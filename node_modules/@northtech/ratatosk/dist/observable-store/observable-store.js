var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ObservableStore_localStoragePrefix, _ObservableStore_data, _ObservableStore_observers, _ObservableStore_serializers, _ObservableStore_deserializers;
import { map, Observable, pairwise, startWith, takeUntil } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';
import { deepEquals } from './deep-equals';
import structuredClone from 'core-js/actual/structured-clone';
/**
 * An `ObservableStore` maintains data of generic type `StoreDataT`, providing methods to set the fields, in turn
 * emitting values on requested `Observable`s. The values are emitted as read-only objects to prevent manipulation of
 * the internal data structure, though it is also possible to request a deep clone of the objects.
 *
 * The `ObservableStore` can write its state to LocalStorage, making it possible to easily recreate the application
 * state when reloading the app.
 *
 * (The `ObservableStore` is itself an `Observable` of type `StoreDataT`, acting like a `BehaviorSubject`,
 * maintaining a single value and replaying it to new subscribers).
 *
 * @example
 *     interface ApplicationData {
 *       name: string;
 *       count: number;
 *     }
 *     const applicationState = new ObservableStore<ApplicationData>({
 *       name: 'Initial value',
 *       count: 0
 *     });
 *     applicationState.observe('name').subscribe(value => console.log(value));
 *     applicationState.set('name', 'New name');
 */
export class ObservableStore extends Observable {
    /**
     * @param initialValue A valid instance of type `StoreDataT`, serving as the initial value of the data.
     * @param fieldsToPersist An object describing which fields in the store data to persist in localStorage. The object
     * consists of keys matching the keys in `StoreDataTÂ´, with either a boolean value (true if the value should be
     * persisted as standard JSON), or an object with custom serializer/deserializers for the field.
     * @param storeNamespace If given, will be used when storing state in LocalStorage. This allows an app to use more
     * than one `ObservableStore` without their values colliding.
     *
     * @example
     *     new ObservableStore<TestObject>(
     *       {a: 'A', b: 1},
     *       {
     *         a: {serializer: v => JSON.stringify(v), deserializer: json => JSON.parse(json)},
     *         b: true
     *       }
     *     );
     */
    constructor(initialValue, fieldsToPersist, storeNamespace) {
        super((observer => {
            // Replay current value to new subscribers:
            observer.next(__classPrivateFieldGet(this, _ObservableStore_data, "f"));
            __classPrivateFieldGet(this, _ObservableStore_observers, "f").add(observer);
            // Teardown logic on unsubscription:
            return () => {
                __classPrivateFieldGet(this, _ObservableStore_observers, "f").delete(observer);
            };
        }));
        _ObservableStore_localStoragePrefix.set(this, 'ObservableStore$');
        _ObservableStore_data.set(this, void 0);
        _ObservableStore_observers.set(this, new Set());
        _ObservableStore_serializers.set(this, {});
        _ObservableStore_deserializers.set(this, {});
        __classPrivateFieldSet(this, _ObservableStore_data, Object.assign({}, initialValue), "f");
        if (fieldsToPersist) {
            const storePrefix = storeNamespace === null || storeNamespace === void 0 ? void 0 : storeNamespace.trim();
            if (storePrefix) {
                __classPrivateFieldSet(this, _ObservableStore_localStoragePrefix, 'ObservableStore-' + storePrefix + '$', "f");
            }
            Object.keys(fieldsToPersist)
                .forEach(k => {
                const serialization = fieldsToPersist[k];
                if (serialization === true) {
                    __classPrivateFieldGet(this, _ObservableStore_serializers, "f")[k] = JSON.stringify;
                    __classPrivateFieldGet(this, _ObservableStore_deserializers, "f")[k] = JSON.parse;
                }
                else if (typeof serialization === 'object') {
                    __classPrivateFieldGet(this, _ObservableStore_serializers, "f")[k] = serialization.serializer ? serialization.serializer : JSON.stringify;
                    __classPrivateFieldGet(this, _ObservableStore_deserializers, "f")[k] = serialization.deserializer ? serialization.deserializer : JSON.parse;
                }
            });
            // A little housekeeping, cleaning up old, now untracked fields so we don't accumulate debris in the localStorage:
            const trackedFields = Object.keys(__classPrivateFieldGet(this, _ObservableStore_deserializers, "f")).map(k => __classPrivateFieldGet(this, _ObservableStore_localStoragePrefix, "f") + k);
            Object.keys(localStorage)
                .filter(key => key.startsWith(__classPrivateFieldGet(this, _ObservableStore_localStoragePrefix, "f")))
                .forEach(key => {
                if (!trackedFields.includes(key)) {
                    localStorage.removeItem(key);
                }
            });
            Object.keys(__classPrivateFieldGet(this, _ObservableStore_deserializers, "f")).forEach(key => {
                var _a, _b;
                try {
                    const storedJson = localStorage.getItem(__classPrivateFieldGet(this, _ObservableStore_localStoragePrefix, "f") + key);
                    if (storedJson != null) {
                        const storedValue = (_b = (_a = __classPrivateFieldGet(this, _ObservableStore_deserializers, "f"))[key]) === null || _b === void 0 ? void 0 : _b.call(_a, storedJson);
                        if (storedValue != null) {
                            __classPrivateFieldGet(this, _ObservableStore_data, "f")[key] = storedValue;
                        }
                    }
                }
                catch (e) {
                    console.log('Error when restoring ' + key + ' from localStorage', e);
                }
            });
        }
    }
    /**
     * Returns the current value of the internal data.
     */
    getValue() {
        return __classPrivateFieldGet(this, _ObservableStore_data, "f");
    }
    set(keyOrKeyValueObject, value) {
        if (typeof keyOrKeyValueObject === 'object') {
            this.setObject(keyOrKeyValueObject);
        }
        else {
            // The implementing signature technically allows for v to be undefined, but the exposed signatures do not, so we
            // simply assert it:
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.setValue(keyOrKeyValueObject, value);
        }
    }
    setValue(key, value) {
        const changed = !deepEquals(__classPrivateFieldGet(this, _ObservableStore_data, "f")[key], value);
        __classPrivateFieldGet(this, _ObservableStore_data, "f")[key] = value;
        this.persist(key, value);
        if (changed) {
            this.notifyObservers();
        }
    }
    setObject(keyValueObject) {
        let changed = false;
        // We lose the typed tuples when going through the plain string keys, but the parameter type ensures that the
        // objects are compatible, so we just assert:
        Object.keys(keyValueObject).forEach(k => {
            changed = changed || !deepEquals(__classPrivateFieldGet(this, _ObservableStore_data, "f")[k], [k]);
            __classPrivateFieldGet(this, _ObservableStore_data, "f")[k] = keyValueObject[k];
            this.persist(k, keyValueObject[k]);
        });
        if (changed) {
            this.notifyObservers();
        }
    }
    persist(key, value) {
        const serializer = __classPrivateFieldGet(this, _ObservableStore_serializers, "f")[key];
        if (serializer) {
            try {
                const json = serializer(value);
                if (json == null) {
                    localStorage.removeItem(__classPrivateFieldGet(this, _ObservableStore_localStoragePrefix, "f") + key);
                }
                else {
                    localStorage.setItem(__classPrivateFieldGet(this, _ObservableStore_localStoragePrefix, "f") + key, json);
                }
            }
            catch (e) {
                console.log('error when storing ' + key, value, e);
            }
        }
    }
    observe(keyOrKeys, ...additionalKeys) {
        let input;
        if (additionalKeys.length > 0) {
            input = Array.isArray(keyOrKeys)
                ? [...keyOrKeys, ...additionalKeys]
                : [keyOrKeys, ...additionalKeys];
        }
        else {
            input = keyOrKeys;
        }
        if (Array.isArray(input)) {
            // We just claim the result to be DeepReadonly to tell the using code "hands off!"
            return this.observeObject(...input);
        }
        else {
            return this.observeValue(input);
        }
    }
    observeClone(keyOrKeys, ...additionalKeys) {
        let input;
        if (additionalKeys.length > 0) {
            input = Array.isArray(keyOrKeys)
                ? [...keyOrKeys, ...additionalKeys]
                : [keyOrKeys, ...additionalKeys];
        }
        else {
            input = keyOrKeys;
        }
        if (Array.isArray(input)) {
            return this.observeObject(...input).pipe(map(o => structuredClone(o)));
        }
        else {
            return this.observeValue(input).pipe(map(o => structuredClone(o)));
        }
    }
    observeValue(key) {
        return this.pipe(map(data => data[key]), distinctUntilChanged((a, b) => deepEquals(a, b)));
    }
    observeObject(...keys) {
        return this.pipe(map(data => {
            const o = {};
            keys.forEach(key => o[key] = data[key]);
            return o;
        }), distinctUntilChanged((a, b) => deepEquals(a, b)));
    }
    observePairwise(keyOrKeys, ...additionalKeys) {
        let input;
        if (additionalKeys.length > 0) {
            input = Array.isArray(keyOrKeys)
                ? [...keyOrKeys, ...additionalKeys]
                : [keyOrKeys, ...additionalKeys];
        }
        else {
            input = keyOrKeys;
        }
        return (Array.isArray(input) ? this.observeObject(...input) : this.observeObject(input)).pipe(startWith(undefined), pairwise());
    }
    apply(updateFunction) {
        const update = updateFunction(__classPrivateFieldGet(this, _ObservableStore_data, "f"));
        // The "as any" here is because we let a Partial masquerade as a Pick. This is not strictly correct unless we
        // use exactOptionalPropertyTypes, and even then the compiler has a hard time typechecking it when dropping
        // through the index access we need to set fields.
        if (update instanceof Promise) {
            update.then(o => this.setObject(o));
        }
        else {
            this.setObject(update);
        }
        return update;
    }
    /**
     * Concats the given element to the list in field `key`, updating the value as per {@link set}
     */
    addToList(key, element) {
        // The key will refer to a list of the appropriate type, or the method signature would not have compiled:
        this.setValue(key, __classPrivateFieldGet(this, _ObservableStore_data, "f")[key].concat(element));
    }
    /*
    // This saves too little at the cost of obscuring the Subscription
    reactTo<K extends keyof T, K2 extends keyof T>(...args: [...K[], (data: Observable<Pick<T, K>>) => Observable<Pick<T, K2>>]): Subscription {
      const updateFunction = args.pop() as (data: Observable<Pick<T, K>>) => Observable<Pick<T, K2>>;
      return updateFunction(this.observe(args as K[]))
        .subscribe(o => this.set(o));
    }
    */
    notifyObservers() {
        __classPrivateFieldGet(this, _ObservableStore_observers, "f").forEach(obs => obs.next(__classPrivateFieldGet(this, _ObservableStore_data, "f")));
    }
    // I am, on principle, not crazy about Angular-specific code creeping into the RxJs-based store, but by using a
    // minimalistic FormControlLike interface we avoid an actual dependency to Angular, and we can probably spare 30 lines
    // of code to support this common use case.
    bindToFormControl(key, formControl, until) {
        if (until) {
            this.observe(key)
                .pipe(takeUntil(until))
                .subscribe(v => {
                if (!deepEquals(v, formControl.value)) {
                    formControl.setValue(v);
                }
            });
            formControl.valueChanges
                .pipe(takeUntil(until))
                .subscribe(v => this.set(key, v));
            return;
        }
        else {
            const sub1 = this.observe(key)
                .subscribe(v => {
                if (!deepEquals(v, formControl.value)) {
                    formControl.setValue(v);
                }
            });
            const sub2 = formControl.valueChanges
                .subscribe(v => this.set(key, v));
            const subscription = {
                closed: false,
                unsubscribe() {
                    this.closed = true;
                    sub1.unsubscribe();
                    sub2.unsubscribe();
                }
            };
            return subscription;
        }
    }
    /**
     * Angular-specific utility method which sets the given keys from a ParamMap-like object in the store, restricted to
     * only the keys which are of type number, string or undefined in the `ObservableStore` (since they are the types
     * which can reliably be expressed in the route without needing custom deserialization).
     * @param params A `ParamMaplike` object, as obtained from Angular's ActivatedRoute.paramMap Observable.
     * @param keys The name of the keys to pick from the `ParamMap` and set in the `ObservableStore`.
     *
     * @example
     *
     *     ngOnInit(): void {
     *       this.activatedRoute.paramMap
     *         .subscribe(paramMap => this.applicationState.setParamMap(paramMap, 'wantedUserId'));
     *       ...
     */
    setParamMap(params, ...keys) {
        const o = {};
        for (const k of keys) {
            const stringK = k.toString();
            if (params.keys.includes(stringK)) {
                const v = params.get(stringK);
                if (v != null) {
                    const parsed = parseInt(v, 10);
                    o[k] = isNaN(parsed) ? v : parsed;
                }
                else {
                    // I am a little unsure about how to handle undefined here. It seems dangerous to explicitly push into the
                    // store, but we need it in the signature.
                    o[k] = undefined;
                }
            }
            else {
                console.error('Required parameter ' + stringK + ' was not given in ParamMap. (Given router parameter names are ' + params.keys + ')');
            }
        }
        this.setObject(o);
        return o;
    }
}
_ObservableStore_localStoragePrefix = new WeakMap(), _ObservableStore_data = new WeakMap(), _ObservableStore_observers = new WeakMap(), _ObservableStore_serializers = new WeakMap(), _ObservableStore_deserializers = new WeakMap();
/*
interface ApplicationData {
  name: string;
  count: number | undefined;
  else: { a: number } | undefined;
}

const applicationState = new ObservableStore<ApplicationData>({
  name: 'Initial value',
  count: 0,
  else: undefined
});
applicationState.observe('name').subscribe(value => console.log(value));
applicationState.set('name', 'New name');

const paramMap = {} as any;

applicationState.setParamMap(paramMap, 'count');

/*
interface Test {
  k1: string;
  k2: number | undefined;
  k3: number[];
}

const observableStore = new ObservableStore<Test>({k1: 'yay', k2: 1, k3: [1, 2, 3]});

observableStore.observePairwise(['k1', 'k2'])
  .pipe(
    map(([prev, curr]) => console.log(prev, curr))
  );

const immutable: DeepReadonly<Test> = {
  k1: 'test',
  k2: 2,
  k3: [4, 5, 6]
};

observableStore.observe('k1', 'k2')
  .subscribe(data => {
    observableStore.set(data);
  });

observableStore.set(immutable);

observableStore.pipe(
  map(data => {
    const o = {
      k1: data.k1,
      k2: data.k2
    };
    return o as DeepReadonly<typeof o>;
  }),
  distinctUntilChanged((a, b) => deepEquals(a, b))
);

observableStore.pipe(
  map(data => {
    const o = data.k1;
    return o as DeepReadonly<typeof o>;
  }),
  distinctUntilChanged((a, b) => deepEquals(a, b))
);
*/
