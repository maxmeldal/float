import { ReplaySubject, share } from 'rxjs';
import { filter, finalize, map, tap } from 'rxjs/operators';
/**
 * This is the internal core of the hash fragment/deeplink functionality.
 * You probably want the browser-enabled {@link UrlFragment} instance exported from <code>url-fragment</code>.
 */
// Having the core logic separated from the I/O events driving it makes it easily testable.
export class UrlFragmentCore {
    /**
     * @param {(s: string) => void} hashSetter A function which will be called when the UrlFragmentCore wants to set the
     * hash in the browser.
     */
    constructor(hashSetter) {
        this.hashSetter = hashSetter;
        /**
         * A stream of key-value params picked up from the URL fragment.
         * Be aware that the maps in this class handle decoded keys (to ensure correct comparison),
         * but encoded values (to be able to parse them into different output formats later).
         */
        this.parameters = new ReplaySubject(1);
        this.paramWatches = new Map();
        // We track the "known" parameters as parsed from the URL:
        this.knownParameters = new Map();
        // Rather than using ".distinctUntilChanged", we track distinct ourselves,
        // to be able to suppress events triggered by our own .set(...)
        this.distinctParams = new Map();
    }
    /**
     * To be called when the hash fragment in the browser URL changes.
     * (This is automatically set up in {@link UrlFragment})
     */
    parse(hashFragment) {
        this.parseHashToKnownParameters(hashFragment);
        this.parameters.next(this.knownParameters);
    }
    /**
     * Returns an observable which will emit when the given key changes in the URL hash fragment.
     */
    watch(key) {
        return this.watchEncoded(key)
            .pipe(map(v => v === undefined ? undefined : decodeURIComponent(v)));
    }
    watchNumber(key) {
        return this.watchEncoded(key)
            .pipe(map(s => (s === undefined || s === '')
            ? undefined
            : parseFloat(decodeURIComponent(s))));
    }
    watchArray(key) {
        return this.watchEncoded(key)
            .pipe(map(v => v === undefined
            ? undefined
            : v.split(';').map(s => decodeURIComponent(s))));
    }
    watchNumberArray(key) {
        return this.watchEncoded(key)
            .pipe(map(v => v === undefined
            ? undefined
            : v.split(';').map(s => parseFloat(decodeURIComponent(s)))));
    }
    /**
     * Setting a value in the hash fragment does <i>not</i> emit a corresponding value in the Observable from the
     * {@link UrlFragment#watch} methods. This is deliberate, to prevent accidental feedback loops, and to avoid that
     * the hash fragment is used as a component-to-component communications channel.
     * It is best to think of the URL fragment as a storage which a service/component can use to store and re-establish
     * its own state, not as a messaging system to other components.
     * As a (very strong) rule of thumb, a component should not <code>set</code> anything that it doesn't itself <code>watch</code>.
     */
    set(key, value) {
        if (value == null) {
            this.knownParameters.delete(key);
            this.distinctParams.delete(key);
        }
        else {
            value = Array.isArray(value)
                ? value.map(v => encodeURIComponent(v.toString())).join(';')
                : encodeURIComponent(value.toString());
            this.knownParameters.set(key, value);
            this.distinctParams.set(key, value);
        }
        this.hashSetter(this.generateHash());
        return this;
    }
    parseHashToKnownParameters(hash) {
        while (hash.startsWith('#')) {
            hash = hash.substring(1);
        }
        this.knownParameters.clear();
        hash.split('&')
            .map(kvp => kvp.split('=', 2))
            .filter(kvp => kvp[1] !== undefined)
            .forEach(kvp => this.knownParameters.set(decodeURIComponent(kvp[0]), kvp[1]));
    }
    watchEncoded(key) {
        let paramWatch = this.paramWatches.get(key);
        if (paramWatch === undefined) {
            paramWatch = this.parameters
                .pipe(map(params => params.get(key)), filter(value => value !== this.distinctParams.get(key)), tap(value => {
                if (value === undefined) {
                    this.distinctParams.delete(key);
                }
                else {
                    this.distinctParams.set(key, value);
                }
            }), 
            // Remove the shared Observable from the hashmap once all subscribers unsubscribe:
            finalize(() => {
                this.paramWatches.delete(key);
                this.distinctParams.delete(key);
            }), share({
                connector: () => new ReplaySubject(1),
                resetOnRefCountZero: true,
                resetOnComplete: true,
                resetOnError: true
            }));
            this.paramWatches.set(key, paramWatch);
        }
        return paramWatch;
    }
    generateHash() {
        const hash = [];
        this.knownParameters.forEach((value, key) => hash.push(encodeURIComponent(key) + '=' + value));
        return '#' + hash.join('&');
    }
}
