// Having an instantiated collator is *insanely* faster than a.localeCompare(b, 'da')
const COLLATOR_DA = new Intl.Collator('da');
/**
 * Allows fluently building a comparator which handles multiple fields in an object.
 *
 * @example
 *
 *     const comparator = new ComparisonChain<Person>()
 *       .compareField(p => p.lastName)
 *       .compareField(p => p.firstName)
 *       .buildComparator();
 *     data.sort(comparator);
 */
export class ComparisonChain {
    /**
     * @param fieldGetters Optionally takes an array of getter functions for fields to compare. In most cases, it is
     * clearer to give them individually and explicitly with the {@link compareField} method.
     * @param collator Optionally takes a Collator. This is equivalent to giving it with the {@link withCollator}
     * method. By defaults uses a `new Intl.Collator('da')`.
     */
    constructor(fieldGetters = [], collator = COLLATOR_DA) {
        this.fieldGetters = fieldGetters;
        this.collator = collator;
    }
    /**
     * Sets the Collator used for comparing strings.
     */
    withCollator(collator) {
        return new ComparisonChain(this.fieldGetters, collator);
    }
    /**
     * Adds a method to extract a given field which should be included in the comparison.
     */
    // We should probably include an ascending/descending option at some point
    compareField(fieldGetter) {
        return new ComparisonChain(this.fieldGetters.concat(fieldGetter), this.collator);
    }
    /**
     * Creates a comparator based on the given fields and Collator.
     */
    buildComparator() {
        if (this.fieldGetters.length) {
            return (a, b) => {
                if (a == undefined && b == undefined) {
                    return 0;
                }
                if (a == undefined) {
                    return -1;
                }
                if (b == undefined) {
                    return 1;
                }
                for (let i = 0; i < this.fieldGetters.length; i++) {
                    const getter = this.fieldGetters[i];
                    const result = compare(getter(a), getter(b), this.collator);
                    if (result !== 0) {
                        return result;
                    }
                }
                return 0;
            };
        }
        else {
            return (a, b) => compare(a, b, this.collator);
        }
    }
}
/**
 * If the parameters are numbers or undefined, this function will return a simple comparison between them. If they are
 * any other type, `.toString()` will be called on them, and passed on to {@link numberAwareStringCompare}.
 */
export function compare(a, b, collator = COLLATOR_DA) {
    if (a == undefined && b == undefined) {
        return 0;
    }
    if (a == undefined) {
        return -1;
    }
    if (b == undefined) {
        return 1;
    }
    if (typeof a === 'number' && typeof b === 'number') {
        return a - b;
    }
    return numberAwareStringCompare(a.toString(), b.toString(), collator);
}
/**
 * Sorts strings, taking into account emebedded (integer) numbers, so e.g. `"A2: Something"` sorts before `"A10: Other"`.
 * @param collator Can be given a Collator to sort according to language rules. By default uses a `new Intl.Collator('da')`.
 */
export function numberAwareStringCompare(s1, s2, collator = COLLATOR_DA) {
    if (s1 == undefined && s2 == undefined) {
        return 0;
    }
    if (s1 == undefined) {
        return -1;
    }
    if (s2 == undefined) {
        return 1;
    }
    let index1 = 0;
    let index2 = 0;
    const length1 = s1.length;
    const length2 = s2.length;
    while (true) {
        // Check if we have hit the end of one or both strings without an decision:
        if (index1 === length1 && index2 === length2) {
            return 0;
        }
        if (index1 === length1) {
            return -1;
        }
        if (index2 === length2) {
            return 1;
        }
        let digit1 = digitAt(s1, index1);
        let digit2 = digitAt(s2, index2);
        // Check if the runners hit a digit simultaneously, and if so, compare the number:
        if (digit1 != undefined && digit2 != undefined) {
            let number1 = digit1;
            index1++;
            // tslint:disable-next-line no-conditional-assignment
            while (index1 < length1 && (digit1 = digitAt(s1, index1++)) !== undefined) {
                number1 = number1 * 10 + digit1;
            }
            let number2 = digit2;
            index2++;
            // tslint:disable-next-line no-conditional-assignment
            while (index2 < length2 && ((digit2 = digitAt(s2, index2++)) !== undefined)) {
                number2 = number2 * 10 + digit2;
            }
            if (number1 < number2) {
                return -1;
            }
            if (number1 > number2) {
                return 1;
            }
        }
        else {
            // Pick up the substrings so we can do a robust collator-based comparison:
            const startPos1 = index1;
            const startPos2 = index2;
            while (index1 < length1 && digitAt(s1, index1) === undefined) {
                index1++;
            }
            while (index2 < length2 && digitAt(s2, index2) === undefined) {
                index2++;
            }
            const comp = collator.compare(s1.substring(startPos1, index1), s2.substring(startPos2, index2));
            if (comp !== 0) {
                return comp;
            }
        }
    }
}
const zero = '0'.charCodeAt(0);
const nine = '9'.charCodeAt(0);
function digitAt(s, pos) {
    const c = s.charCodeAt(pos);
    return c >= zero && c <= nine ? c - zero : undefined;
}
