TrigramIndex
============

A Typescript/Javascript implementation of a trigram fuzzy search.

You can add "documents", i.e. any Javascript objects, to the index, and query for fuzzy text search.

By default, all top-level strings and numbers in the objects will be searched,
but you can provide a mapper function to specify which text should form the basis for the search index.

Simply import `TrigramIndex` in your project, create an `index = new TrigramIndex<MyDocumentType>()`,
and add documents to it with `index.add(...)`, or use the typed static `TrigramIndex.of([...])` method.

You can then call `index.find(...)` to fuzzy-search for added documents.

Refer to the JsDoc for additional options.


The concept behind a trigram search index
-----------------------------------------

The task is: Given a collection of "documents" (in practice, JavaScript objects with a searchable text representation)
and a – typically short – search string, find the documents which "best match" the search string, with some tolerance
for typos.

Conceptually, the trigram search works by splitting the search string into overlapping groups of three letters, the
eponymous trigrams. So, for example, "trigram" becomes ["TRI", "RIG", "IGR", "GRA", "RAM"].

For each trigram in the search string, we scan through each document to see if it contains the trigram. If it does, the
document scores a point, and at the end, we sort documents by points.

Notice that we do not care about *where* in the document the trigram is found; only that it is in the document
somewhere. (Because of this, we only consider *unique* trigrams. It does not make sense to let different parts of the
search string score multiple hits against the same letters in the document).

The sequence of letters is still implicitly taken into consideration since each trigram has a two-letter overlap with
the previous, so a long, correct sequence in the search document will match many overlapping trigrams, boosting the
score.

Of course, doing multiple string matches against every document for each search is not optimal, and this is where the
"index" part comes in.
We pre-calculate a lookup map with every (relevant) trigram and the documents which contain it. Doing a search then
becomes a matter of turning each trigram in the search string into a list of documents by simple lookup in the map, and
count which documents appear how many times in the lists.

Angular use
-----------
While this implementation has no dependencies, it can be used elegantly in Angular by leveraging the "reactive" style:

    const source: Observable<MyDocument[]> = ...likely some variant of an HTTP call fetching the source data, or a ReplaySubject carrying the freshest data;
    const searchString: Observable<string> = ...typically fed from an input field;	
    ...
    const trigramIndex = source.pipe(map(documents => TrigramIndex.of(documents)));
    this.searchResult = combineLatest(trigramIndex, searchString).pipe(map(params => params[0].find(params[1])));
	
This will produce an Observable<MyDocument[]> of search results which will wait until we have both source data and a
search query, and will emit a new result each time either of those change, and the template can simply subscribe to the
results with a `*ngFor="let document of searchResult | async`". 

One advantage of doing it this way is that when the template expressions are driven by async subscriptions, you can use
the optimized `ChangeDetectionStrategy.OnPush`.

(You may need some `.shareReplay(1)` on some of those observables, depending on how you reuse them and un/resubscribe to
them).
