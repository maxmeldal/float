/**
 * Provides a fuzzy text search in the fields of a collection of JavaScript objects.
 */
export class TrigramIndex<T> {
  // Should this be a map for easy deletion?
  private readonly docList: T[] = [];
  private stringMapper: (doc: T) => string = TrigramIndex.defaultSearchStringMapper;
  private docsByTrigram: { [index: string]: number[] } = {};
  private resultForEmptySearch: (() => T[]) | undefined;

  private static defaultSearchStringMapper(o: any): string {
    return typeof o === 'string'
      ? o
      : Object.keys(o)
        .map(k => o[k])
        .filter(v => typeof v === 'string' || typeof v === 'number')
        // We use two spaces here to separate each value, making sure the new word get its own starting trigram:
        .join('  ');
  }

  /**
   * Turns a text string into an array of uppercase trigrams. Used internally.
   */
  private static uniqueTrigrams(s: string): string[] {
    // By starting all strings with two spaces, we both ensure that we always have three letters for a full trigram,
    // and also give preference to the start of the string since it creates a matching sequence against
    // the spaces and the first letter(s). This is a somewhat arbitrary decision, but pragmatically it works well.
    // Additionally, we insert a space between any non-letter and letter so, say, "Church-Turing" becomes
    // "Church- Turing", yielding a better hit when "  Turing" is used as search word.
    // This, too, is an arbitrary but pragmatically effective choice.
    s = '  ' + s.trim().toLocaleUpperCase()
      .replace(/([^\w\u00C0-\u00FF])([\w\u00C0-\u00FF])/g, '$1 $2')
      // And finally, we convert all whitespace to two spaces,
      // to make all starting letters of words match a single-letter search.
      // (Pragmatically, it violates the principle of least astonishment if, say,
      // "Jes Wulfsberg Nielsen" doesn't show up when people start typing "w".
      // Without the boosted spaces, the search trigram "  W" wouldn't match the existing "S W").
      .replace(/\s+/g, '  ');

    // Use object keys as a set:
    const trigramObject: { [index: string]: boolean } = {};
    for (let i = 0; i < s.length - 2; i++) {
      trigramObject[s.substr(i, 3)] = true;
    }
    return Object.keys(trigramObject);
  }

  /**
   * Builds a new TrigramIndex based on the given array and search-string mapper function.
   */
  static of<U>(docs: Iterable<U>, mapperFunction?: (doc: U) => string): TrigramIndex<U> {
    return mapperFunction
      ? new TrigramIndex<U>().searchStringMapper(mapperFunction).addAll(docs)
      : new TrigramIndex<U>().addAll(docs);
  }

  /**
   * The mapper function given here will be used to turn document objects of type T into text to be used
   * as searchable keywords.
   * Be aware that if this method is called after documents have already been added, the index will be completely
   * rebuilt using the new mapper function, so you generally want to call this function <i>before</i> {@link addAll}, or
   * use the convenient, type-inferring static shorthand {@link TrigramIndex.of}.
   *
   * @param mapperFunction A function taking an object of type T and returning a string.
   * @returns "this", for chain notations.
   */
  searchStringMapper(mapperFunction: (doc: T) => string): TrigramIndex<T> {
    this.stringMapper = mapperFunction;
    // Recreate the index if we already had registered documents:
    if (this.docList.length) {
      const currentDocs = this.docList.slice();
      this.docList.length = 0;
      this.docsByTrigram = {};
      this.addAll(currentDocs);
    }
    return this;
  }

  /**
   * If an empty string is given to the {@link find} function, the TrigramIndex will return the full list of documents.
   * This is useful if the search represents a narrowing of data which is also paginated, such as in a table view.
   * @see emptySearchReturnsNone
   * @see emptySearchReturnsAllIfFewerThan
   * @see emptySearchReturns
   */
  emptySearchReturnsAll(): this {
    return this.emptySearchReturns(() => this.docList);
  }

  /**
   * If an empty string is given to the {@link find} function, the TrigramIndex will return an empty array.
   * This is useful if the search represents an active user action, not showing anything until the user has typed some
   * search criteria.
   * @see emptySearchReturnsAll
   * @see emptySearchReturnsAllIfFewerThan
   * @see emptySearchReturns
   */
  emptySearchReturnsNone(): this {
    return this.emptySearchReturns(() => []);
  }

  /**
   * If an empty string is given to the {@link find} function, it may return either an empty array, or all documents.
   * The primary use case for this is a combobox where a dropdown presents the available choices even before the user
   * starts typing anything to narrow it down, but it doesn't make sense to show the full list when there are too many
   * entries, since it would overwhelm the UI in both size and performance.
   *
   * @param {number} threshold If the total number of documents in the TrigramIndex is less than this threshold, the
   * full list will be returned when the search string is empty.
   * @see emptySearchReturnsAll
   * @see emptySearchReturnsNone
   * @see emptySearchReturns
   */
  emptySearchReturnsAllIfFewerThan(threshold: number): this {
    return this.emptySearchReturns(() => this.docList.length < threshold ? this.docList : []);
  }

  /**
   * If an empty string is given to the {@link find} function, this function will be invoked to provide the list.
   * An example use of this could be to track the most recently used documents, and return those when the search string
   * is empty.
   *
   * @see emptySearchReturnsAll
   * @see emptySearchReturnsAllIfFewerThan
   * @see emptySearchReturnsNone
   */
  emptySearchReturns(supplier: () => T[]): this {
    this.resultForEmptySearch = supplier;
    return this;
  }

  /**
   * Adds all document objects in the array, using the mapper function to generate the search keywords.
   * @param docs An array of objects of type T.
   * @returns "this", for chain notations.
   */
  addAll(docs: Iterable<T>): TrigramIndex<T> {
    for (const doc of docs) {
      this.add(doc);
    }
    return this;
  }

  /**
   * Adds the given "document" to the search index.
   * @param doc An object of type T.
   * @param searchableString (Optional) The keywords the given object can be found by, i.e. some relevant text
   * representation of the object. If no string is given here, the mapper given by {@link searchStringMapper}
   * (possibly the default mapper) will be used to generate a string.
   * @returns "this", for chain notations.
   */
  add(doc: T, searchableString?: string): TrigramIndex<T> {
    if (!searchableString) {
      searchableString = this.stringMapper(doc);
    }
    const docIndex = this.docList.push(doc) - 1;

    for (const trigram of TrigramIndex.uniqueTrigrams(searchableString)) {
      let docsBelongingToTrigram = this.docsByTrigram[trigram];
      if (!docsBelongingToTrigram) {
        this.docsByTrigram[trigram] = (docsBelongingToTrigram = []);
      }
      docsBelongingToTrigram.push(docIndex);
    }
    return this;
  }

  /**
   * Performs a fuzzy search amongst the registered document objects.
   * @param searchString The text to search for.
   * If an empty string or undefined is given, the index will return either an empty array, or all documents,
   * depending the setting of {@link emptySearchReturnsAllIfFewerThan}
   * @param maxHits The maximum number of documents this function should return.
   * @param quality A number from 0 to 1, describing the fraction of search trigrams which must be found in a
   * document for it to be considered a usable result. By requiring a certain threshold, we prevent the algorithm
   * from returning technically-best-but-practically-irrelevant results.
   * @returns An array of objects of type T, sorted by relevance.
   */
  find(searchString: string | undefined, maxHits = 10, quality = 0.3): T[] {
    /*
    if (!searchString) {
      return this.docList.length <= this.emptySearchReturnsAllThreshold
        ? this.docList
        : [];
    }
    */
    if (!searchString) {
      return this.resultForEmptySearch
        ? this.resultForEmptySearch()
        : (this.docList.length < 200 ? this.docList : []);
    }
    const trigramHitsInDocument: { [index: string]: number } = {};
    const searchTrigrams = TrigramIndex.uniqueTrigrams(TrigramIndex.defaultSearchStringMapper(searchString));
    for (const trigram of searchTrigrams) {
      const docList = this.docsByTrigram[trigram];
      if (docList) {
        for (const docIndex of docList) {
          if (trigramHitsInDocument[docIndex]) {
            trigramHitsInDocument[docIndex]++;
          } else {
            trigramHitsInDocument[docIndex] = 1;
          }
        }
      }
    }

    let scoredResults: { document: T, score: number }[] = [];
    for (const docIndex of Object.keys(trigramHitsInDocument)) {
      const score = trigramHitsInDocument[docIndex] / searchTrigrams.length;
      if (score >= quality) {
        scoredResults.push({
          document: this.docList[parseInt(docIndex, 10)],
          score
        });
      }
    }
    scoredResults = scoredResults.sort((a, b) => b.score - a.score);

    const result: T[] = [];
    let neededHits = scoredResults.length;
    if (maxHits > 0) {
      neededHits = maxHits < neededHits ? maxHits : neededHits;
    }
    for (let i = 0; i < neededHits; i++) {
      result.push(scoredResults[i].document);
    }
    return result;
  }
}
