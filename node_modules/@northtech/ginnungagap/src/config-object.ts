export interface ConfigObject {
  [index: string]: string | number | undefined;
}

/**
 * Assembles a {@link ConfigObject} from a parameter list, accepting multiple notations:
 *
 * Each entry in the list can be
 *  * another object, in which case the keys and values are transferred to the generated config object
 *  * an array, which must have exactly two elements, on the form `[key, value]`
 *  * two consecutive parameters, which will be interpreted as `key, value`.
 *
 *  e.g. `toConfigObject('a', 1, {b: 2, d: 4}, ['c', 3])` will result in an object looking like `{a: 1, b: 2, c: 3, d: 4}`
 *
 *  The keys will always be strings, and the values will be undefined, number or string (with any other value having
 *  toString() called on it).
 *
 *  This function should generally not be called directly. It is primarily meant as an internal helper function for
 *  methods which for some reason has several complicated overload signatures.
 *
 *  Also, consider whether the ES6 Â´Object.fromEntries()` fulfills the purpose.
 */
export function toConfigObject(...o: unknown[]): ConfigObject {
  const c: ConfigObject = {};
  for (let i = 0; i < o.length; i++) {
    const el = o[i];
    // Skip over nullish values:
    if (el == undefined) {
      continue;
    }
    if (Array.isArray(el)) {
      // Key/value as a two-element array:
      if (el.length != 2) {
        throw new Error('Key/value arrays must contain two elements');
      }
      const elArray = el as unknown[];
      if (elArray[0] != undefined) {
        c[(elArray[0] as any).toString()] = toValue(elArray[1]);
      }
    } else if (typeof el === 'object') {
      for (const key in el) {
        if (Object.prototype.hasOwnProperty.call(el, key)) {
          c[key.toString()] = toValue((el as any)[key]);
        }
      }
    } else {
      if (i + 1 >= o.length) {
        throw new Error('Incorrect number of parameters');
      }
      c[(el as any).toString()] = toValue(o[i + 1]);
      i++;
    }
  }
  return c;
}

function toValue(o: any): string | number | undefined {
  if (!o) {
    return undefined;
  }
  if (typeof o == 'number') {
    return o;
  }
  return o.toString();
}

/**
 * @deprecated Use {@link toConfigObject}
 */
export function collapseParamsToConfigObject(
  nameOrConfigObject: ConfigObject | string,
  value?: string | number | undefined,
  name2?: string,
  value2?: string | number | undefined,
  name3?: string,
  value3?: string | number | undefined,
  name4?: string,
  value4?: string | number | undefined
): ConfigObject {
  return toConfigObject(nameOrConfigObject, value, name2, value2, name3, value3, name4, value4);
}
